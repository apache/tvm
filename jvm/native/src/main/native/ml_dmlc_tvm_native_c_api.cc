#include "ml_dmlc_tvm_native_c_api.h"  // generated by javah
#include <dmlc/logging.h>
#include <tvm/runtime/c_runtime_api.h>
#include <iostream>

#include "jni_helper_func.h"

JavaVM *_jvm;

JNIEXPORT jint JNICALL Java_ml_dmlc_tvm_LibInfo_nativeLibInit
  (JNIEnv *env, jobject obj) {
  return env->GetJavaVM(&_jvm);
}

JNIEXPORT jstring JNICALL Java_ml_dmlc_tvm_LibInfo_tvmGetLastError(JNIEnv * env, jobject obj) {
  return env->NewStringUTF(TVMGetLastError());
}

// Function
JNIEXPORT jint JNICALL Java_ml_dmlc_tvm_LibInfo_tvmFuncListGlobalNames(
  JNIEnv *env, jobject obj, jobject jfuncNames) {
  int outSize;
  const char **outArray;

  int ret = TVMFuncListGlobalNames(&outSize, &outArray);
  if (ret) {
    return ret;
  }

  jclass arrayClass = env->FindClass("scala/collection/mutable/ArrayBuffer");
  jmethodID arrayAppend = env->GetMethodID(arrayClass,
    "$plus$eq", "(Ljava/lang/Object;)Lscala/collection/mutable/ArrayBuffer;");

  // fill names
  for (int i = 0; i < outSize; ++i) {
    jstring jname = env->NewStringUTF(outArray[i]);
    env->CallObjectMethod(jfuncNames, arrayAppend, jname);
    env->DeleteLocalRef(jname);
  }

  return ret;
}

JNIEXPORT jint JNICALL Java_ml_dmlc_tvm_LibInfo_tvmFuncFree(
  JNIEnv *env, jobject obj, jlong jhandle) {
  return TVMFuncFree(reinterpret_cast<TVMFunctionHandle>(jhandle));
}

JNIEXPORT jint JNICALL Java_ml_dmlc_tvm_LibInfo_tvmFuncCall(
  JNIEnv *env, jobject obj, jlong jhandle, jobjectArray jargs, jobject jretVal) {
  jclass tvmArgClass = env->FindClass("ml/dmlc/tvm/types/TVMValue");
  jfieldID tvmArgId = env->GetFieldID(tvmArgClass, "argTypeId", "I");

  int numArgs = static_cast<int>(env->GetArrayLength(jargs));

  TVMValue *argValues = new TVMValue[numArgs];
  int *typeCodes = new int[numArgs];

  for (int i = 0; i < numArgs; ++i) {
    jobject jarg = env->GetObjectArrayElement(jargs, i);
    int argId = static_cast<int>(env->GetIntField(jarg, tvmArgId));
    TVMValue value;
    switch (argId) {
      case 0:
        value.v_int64 = static_cast<int64_t>(getTVMValueLongField(env, jarg));
        break;
      case 2:
        value.v_float64 = static_cast<double>(getTVMValueDoubleField(env, jarg));
        break;
      default:
        // TODO
        LOG(FATAL) << "Do NOT know how to handle argId " << argId;
    }
    typeCodes[i] = argId;
    argValues[i] = value;
  }

  TVMValue retVal;
  int retTypeCode;
  int ret = TVMFuncCall(reinterpret_cast<TVMFunctionHandle>(jhandle),
                        argValues, typeCodes, numArgs, &retVal, &retTypeCode);

  delete[] typeCodes;
  delete[] argValues;
  env->DeleteLocalRef(tvmArgClass);

  // return TVMValue object to Java
  jclass refTVMValueCls = env->FindClass("ml/dmlc/tvm/Base$RefTVMValue");
  jfieldID refTVMValueFid = env->GetFieldID(refTVMValueCls, "value", "Lml/dmlc/tvm/types/TVMValue");

  switch (retTypeCode) {
    case 0:
      env->SetObjectField(jretVal, refTVMValueFid,
        newTVMValueLong(env, static_cast<jlong>(retVal.v_int64)));
      break;
    case 2:
      env->SetObjectField(jretVal, refTVMValueFid,
        newTVMValueDouble(env, static_cast<jdouble>(retVal.v_float64)));
      break;
    default:
      // TODO
      LOG(FATAL) << "Do NOT know how to handle return type code " << retTypeCode;
  }

  env->DeleteLocalRef(refTVMValueCls);

  return ret;
}

// NDArray
JNIEXPORT jint JNICALL Java_ml_dmlc_tvm_LibInfo_tvmArrayFree(
  JNIEnv *env, jobject obj, jlong jhandle) {
  return TVMArrayFree(reinterpret_cast<TVMArrayHandle>(jhandle));
}
