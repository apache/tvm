# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020 - 2021, Apache Software Foundation
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm 0.8.dev1713+gbe5f05f3f\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-09-18 01:16+0000\n"
"PO-Revision-Date: 2021-09-18 07:45+0000\n"
"Language-Team: Chinese (China) (https://www.transifex.com/TVMChinese/teams/124815/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../_staging/langref/relay_type.rst:20
msgid "Relay's Type System"
msgstr ""

#: ../../_staging/langref/relay_type.rst:22
msgid ""
"We briefly introduced types while detailing Relay's expression language, but"
" have not yet described its type system. Relay is a statically typed and "
"type-inferred language, allowing programs to be fully typed while requiring "
"just a few explicit type annotations."
msgstr ""

#: ../../_staging/langref/relay_type.rst:27
msgid ""
"Static types are useful when performing compiler optimizations because they "
"communicate properties about the data a program manipulates, such as runtime"
" shape, data layout, and storage, without needing to run the program. "
"Relay's `Algebraic Data Types`_ allow for easily and flexibly composing "
"types in order to build data structures that can be reasoned about "
"inductively and used to write recursive functions."
msgstr ""

#: ../../_staging/langref/relay_type.rst:34
msgid ""
"Relay's type system features a form of *dependent typing* for shapes. That "
"is, its type system keeps track of the shapes of tensors in a Relay program."
" Treating tensor shapes as types allows Relay to perform more powerful "
"reasoning at compile time; in particular, Relay can statically reason about "
"operations whose output shapes vary based on the input shapes in complex "
"ways. Casting shape inference as a type inference problem allows Relay to "
"infer the shapes of all tensors at compile time, including in programs that "
"use branching and function calls."
msgstr ""

#: ../../_staging/langref/relay_type.rst:41
msgid ""
"Statically reasoning about shapes in this manner allows Relay to be ahead-"
"of-time compiled and provides much more information about tensors for "
"optimizations further in the compilation pipeline. Such optimizations can be"
" implemented as passes, which are Relay-to-Relay AST transformations, and "
"may use the inferred types (e.g., shape information) for making decisions "
"about program transformations. For instance, "
":code:`src/relay/transforms/fuse_ops.cc` gives an implementation of a pass "
"that uses inferred tensor shapes to replace invocations of operators in a "
"Relay program with fused operator implementations."
msgstr ""

#: ../../_staging/langref/relay_type.rst:50
msgid ""
"Reasoning about tensor types in Relay is encoded using *type relations*, "
"which means that the bulk of type checking in Relay is constraint solving "
"(ensuring that all type relations are satisfied at call sites). Type "
"relations offer a flexible and relatively simple way of making the power of "
"dependent typing available in Relay without greatly increasing the "
"complexity of its type system."
msgstr ""

#: ../../_staging/langref/relay_type.rst:56
msgid ""
"Below we detail the language of types in Relay and how they are assigned to "
"Relay expressions."
msgstr ""

#: ../../_staging/langref/relay_type.rst:59
msgid "Type"
msgstr ""

#: ../../_staging/langref/relay_type.rst:61
msgid ""
"The base type for all Relay types. All Relay types are sub-classes of this "
"base type."
msgstr ""

#: ../../_staging/langref/relay_type.rst:63
msgid ""
"See :py:class:`~tvm.relay.ty.Type` for its definition and documentation."
msgstr ""

#: ../../_staging/langref/relay_type.rst:66
msgid "Tensor Type"
msgstr ""

#: ../../_staging/langref/relay_type.rst:68
msgid "A concrete tensor type in Relay."
msgstr ""

#: ../../_staging/langref/relay_type.rst:70
msgid ""
"Tensors are typed according to data type and shape. At present, these use "
"TVM's data types and shapes, but in the future, Relay may include a separate"
" AST for shapes. In particular, data types include :code:`bool`, "
":code:`float32`, :code:`int8` and various other bit widths and numbers of "
"lanes. Shapes are given as tuples of dimensions (TVM :code:`IndexExpr`), "
"such as :code:`(5, 5)`; scalars are also given tuple types and have a shape "
"of :code:`()`."
msgstr ""

#: ../../_staging/langref/relay_type.rst:76
msgid ""
"Note, though, that TVM shapes can also include variables and arithmetic "
"expressions including variables, so Relay's constraint solving phase will "
"attempt to find assignments to all shape variables to ensure all shapes will"
" be concrete before running a program."
msgstr ""

#: ../../_staging/langref/relay_type.rst:81
msgid ""
"For example, here is a simple concrete tensor type corresponding to a "
"10-by-10 tensor of 32-bit floats:"
msgstr ""

#: ../../_staging/langref/relay_type.rst:87
msgid ""
"See :py:class:`~tvm.relay.ty.TensorType` for its definition and "
"documentation."
msgstr ""

#: ../../_staging/langref/relay_type.rst:90
msgid "Tuple Type"
msgstr ""

#: ../../_staging/langref/relay_type.rst:92
msgid "A type of a tuple in Relay."
msgstr ""

#: ../../_staging/langref/relay_type.rst:94
msgid ""
"Just as a tuple is simply a sequence of values of statically known length, "
"the type of a tuple consists of a sequence of the types corresponding to "
"each member of the tuple."
msgstr ""

#: ../../_staging/langref/relay_type.rst:97
msgid ""
"Because a tuple type is of statically known size, the type of a tuple "
"projection is simply the corresponding index into the tuple type."
msgstr ""

#: ../../_staging/langref/relay_type.rst:100
msgid ""
"For example, in the below code, :code:`%t` is of type :code:`(Tensor[(), "
"bool], Tensor[(10, 10), float32])` and :code:`%c` is of type "
":code:`Tensor[(10, 10), float32]`."
msgstr ""

#: ../../_staging/langref/relay_type.rst:110
msgid ""
"See :py:class:`~tvm.relay.ty.TupleType` for its definition and "
"documentation."
msgstr ""

#: ../../_staging/langref/relay_type.rst:115
msgid "Type Parameter"
msgstr ""

#: ../../_staging/langref/relay_type.rst:117
msgid ""
"Type parameters represent placeholder types used for polymorphism in "
"functions. Type parameters are specified according to *kind*, corresponding "
"to the types those parameters are allowed to replace:"
msgstr ""

#: ../../_staging/langref/relay_type.rst:121
msgid ""
":code:`Type`, corresponding to top-level Relay types like tensor types, "
"tuple types, and function types"
msgstr ""

#: ../../_staging/langref/relay_type.rst:122
msgid ""
":code:`BaseType`, corresponding to the base type of a tensor (e.g., "
":code:`float32`, :code:`bool`)"
msgstr ""

#: ../../_staging/langref/relay_type.rst:123
msgid ":code:`Shape`, corresponding to a tensor shape"
msgstr ""

#: ../../_staging/langref/relay_type.rst:124
msgid ":code:`ShapeVar`, corresponding to variables within a tensor shape"
msgstr ""

#: ../../_staging/langref/relay_type.rst:126
msgid ""
"Relay's type system enforces that type parameters are only allowed to appear"
" where their kind permits them, so if type variable :code:`t` is of kind "
":code:`Type`, :code:`Tensor[t, float32]` is not a valid type."
msgstr ""

#: ../../_staging/langref/relay_type.rst:131
msgid ""
"Like normal parameters, concrete arguments must be given for type parameters"
" at call sites."
msgstr ""

#: ../../_staging/langref/relay_type.rst:135
msgid ""
"For example, :code:`s` below is a type parameter of kind :code:`Shape` and "
"it will be substituted with :code:`(10, 10)` at the call site below:"
msgstr ""

#: ../../_staging/langref/relay_type.rst:145
msgid ""
"See :py:class:`~tvm.relay.ty.TypeVar` for its definition and documentation."
msgstr ""

#: ../../_staging/langref/relay_type.rst:148
msgid "Type Constraint"
msgstr ""

#: ../../_staging/langref/relay_type.rst:150
msgid ""
"This is an abstract class representing a type constraint, to be elaborated "
"upon in further releases. Currently, type relations are the only type "
"constraints provided; they are discussed below."
msgstr ""

#: ../../_staging/langref/relay_type.rst:154
msgid ""
"See :py:class:`~tvm.relay.ty.TypeConstraint` for its definition and "
"documentation."
msgstr ""

#: ../../_staging/langref/relay_type.rst:157
msgid "Function Type"
msgstr ""

#: ../../_staging/langref/relay_type.rst:159
msgid "A function type in Relay, see `tvm/relay/type.h` for more details."
msgstr ""

#: ../../_staging/langref/relay_type.rst:161
msgid ""
"This is the type assigned to functions in Relay. A function type consists of"
" a list of type parameters, a set of type constraints, a sequence of "
"argument types, and a return type."
msgstr ""

#: ../../_staging/langref/relay_type.rst:165
msgid ""
"We informally write function types as: :code:`fn<type_params>(arg_types) -> "
"ret_type where type_constraints`"
msgstr ""

#: ../../_staging/langref/relay_type.rst:168
msgid ""
"A type parameter in the function type may appear in the argument types or "
"the return types. Additionally, each of the type constraints must hold at "
"every call site of the function. The type constraints typically take the "
"function's argument types and the function's return type as arguments, but "
"may take a subset instead."
msgstr ""

#: ../../_staging/langref/relay_type.rst:174
msgid ""
"See :py:class:`~tvm.relay.ty.FuncType` for its definition and documentation."
msgstr ""

#: ../../_staging/langref/relay_type.rst:179
msgid "Type Relation"
msgstr ""

#: ../../_staging/langref/relay_type.rst:181
msgid ""
"A type relation is the most complex type system feature in Relay. It allows "
"users to extend type inference with new rules. We use type relations to "
"define types for operators that work with tensor shapes in complex ways, "
"such as broadcasting operators or :code:`flatten`, allowing Relay to "
"statically reason about the shapes in these cases."
msgstr ""

#: ../../_staging/langref/relay_type.rst:188
msgid ""
"A type relation :code:`R` describes a relationship between the input and "
"output types of a Relay function. Namely, :code:`R` is a function on types "
"that outputs `true` if the relationship holds and `false` if it fails to "
"hold. Types given to a relation may be incomplete or include shape "
"variables, so type inference must assign appropriate values to incomplete "
"types and shape variables for necessary relations to hold, if such values "
"exist."
msgstr ""

#: ../../_staging/langref/relay_type.rst:196
msgid "For example we can define an identity relation to be:"
msgstr ""

#: ../../_staging/langref/relay_type.rst:202
msgid ""
"It is usually convenient to type operators in Relay by defining a relation "
"specific to that operator that encodes all the necessary constraints on the "
"argument types and the return type. For example, we can define the relation "
"for :code:`flatten`:"
msgstr ""

#: ../../_staging/langref/relay_type.rst:212
msgid ""
"If we have a relation like :code:`Broadcast` it becomes possible to type "
"operators like :code:`add`:"
msgstr ""

#: ../../_staging/langref/relay_type.rst:220
msgid ""
"The inclusion of :code:`Broadcast` above indicates that the argument types "
"and the return type must be tensors where the shape of :code:`t3` is the "
"broadcast of the shapes of :code:`t1` and :code:`t2`. The type system will "
"accept any argument types and return type so long as they fulfill "
":code:`Broadcast`."
msgstr ""

#: ../../_staging/langref/relay_type.rst:226
msgid ""
"Note that the above example relations are written in Prolog-like syntax, but"
" currently the relations must be implemented by users in C++ or Python. More"
" specifically, Relay's type system uses an *ad hoc* solver for type "
"relations in which type relations are actually implemented as C++ or Python "
"functions that check whether the relation holds and imperatively update any "
"shape variables or incomplete types. In the current implementation, the "
"functions implementing relations should return :code:`False` if the relation"
" fails to hold and :code:`True` if the relation holds or if there is not "
"enough information to determine whether it holds or not."
msgstr ""

#: ../../_staging/langref/relay_type.rst:236
msgid ""
"The functions for all the relations are run as needed (if an input is "
"updated) until one of the following conditions holds:"
msgstr ""

#: ../../_staging/langref/relay_type.rst:239
msgid ""
"All relations hold and no incomplete types remain (typechecking succeeds)."
msgstr ""

#: ../../_staging/langref/relay_type.rst:240
msgid "A relation fails to hold (a type error)."
msgstr ""

#: ../../_staging/langref/relay_type.rst:241
msgid ""
"A fixpoint is reached where shape variables or incomplete types remain "
"(either a type error or more type annotations may be needed)."
msgstr ""

#: ../../_staging/langref/relay_type.rst:243
msgid ""
"Presently all of the relations used in Relay are implemented in C++. See the"
" files in :code:`src/relay/op` for examples of relations implemented in C++."
msgstr ""

#: ../../_staging/langref/relay_type.rst:247
msgid ""
"See :py:class:`~tvm.relay.ty.TypeRelation` for its definition and "
"documentation."
msgstr ""

#: ../../_staging/langref/relay_type.rst:250
msgid "Incomplete Type"
msgstr ""

#: ../../_staging/langref/relay_type.rst:252
msgid ""
"An incomplete type is a type or portion of a type that is not yet known. "
"This is only used during type inference. Any omitted type annotation is "
"replaced by an incomplete type, which will be replaced by another type at a "
"later point."
msgstr ""

#: ../../_staging/langref/relay_type.rst:257
msgid ""
"Incomplete types are known as \"type variables\" or \"type holes\" in the "
"programming languages literature. We use the name \"incomplete type\" in "
"order to more clearly distinguish them from type parameters: Type parameters"
" must be bound to a function and are replaced with concrete type arguments "
"(instantiated) at call sites, whereas incomplete types may appear anywhere "
"in the program and are filled in during type inference."
msgstr ""

#: ../../_staging/langref/relay_type.rst:262
msgid ""
"See :py:class:`~tvm.relay.ty.IncompleteType` for its definition and "
"documentation."
msgstr ""

#: ../../_staging/langref/relay_type.rst:267
msgid "Algebraic Data Types"
msgstr ""

#: ../../_staging/langref/relay_type.rst:269
msgid "*Note: ADTs are not currently supported in the text format.*"
msgstr ""

#: ../../_staging/langref/relay_type.rst:271
msgid ""
"Algebraic data types (ADTs) are described in more detail in :ref:`their "
"overview <adt-overview>`; this section describes their implementation in the"
" type system."
msgstr ""

#: ../../_staging/langref/relay_type.rst:275
msgid ""
"An ADT is defined by a collection of named constructors, each of which takes"
" arguments of certain types. An instance of an ADT is a container that "
"stores the values of the constructor arguments used to produce it as well as"
" the name of the constructor; the values can be retrieved by deconstructing "
"the instance by matching based on its constructor. Hence, ADTs are sometimes"
" called \"tagged unions\": like a C-style union, the contents of an instance"
" for a given ADT may have different types in certain cases, but the "
"constructor serves as a tag to indicate how to interpret the contents."
msgstr ""

#: ../../_staging/langref/relay_type.rst:286
msgid ""
"From the type system's perspective, it is most pertinent that ADTs can take "
"type parameters (constructor arguments can be type parameters, though ADT "
"instances with different type parameters must be treated as different types)"
" and be recursive (a constructor for an ADT can take an instance of that "
"ADT, thus an ADT like a tree or list can be inductively built up). The "
"representation of ADTs in the type system must be able to accommodate these "
"facts, as the below sections will detail."
msgstr ""

#: ../../_staging/langref/relay_type.rst:296
msgid "Global Type Variable"
msgstr ""

#: ../../_staging/langref/relay_type.rst:298
msgid ""
"To represent ADTs compactly and easily allow for recursive ADT definitions, "
"an ADT definition is given a handle in the form of a global type variable "
"that uniquely identifies it. Each ADT definition is given a fresh global "
"type variable as a handle, so pointer equality can be used to distinguish "
"different ADT names."
msgstr ""

#: ../../_staging/langref/relay_type.rst:304
msgid ""
"For the purposes of Relay's type system, ADTs are differentiated by name; "
"that means that if two ADTs have different handles, they will be considered "
"different types even if all their constructors are structurally identical."
msgstr ""

#: ../../_staging/langref/relay_type.rst:309
msgid ""
"Recursion in an ADT definition thus follows just like recursion for a global"
" function: the constructor can simply reference the ADT handle (global type "
"variable) in its definition."
msgstr ""

#: ../../_staging/langref/relay_type.rst:313
msgid ""
"See :py:class:`~tvm.relay.ty.GlobalTypeVar` for its definition and "
"documentation."
msgstr ""

#: ../../_staging/langref/relay_type.rst:316
msgid "Definitions (Type Data)"
msgstr ""

#: ../../_staging/langref/relay_type.rst:318
msgid ""
"Besides a name, an ADT needs to store the constructors that are used to "
"define it and any type parameters used within them. These are stored in the "
"module, :ref:`analogous to global function definitions<module-description>`."
msgstr ""

#: ../../_staging/langref/relay_type.rst:322
msgid ""
"While type-checking uses of ADTs, the type system sometimes must index into "
"the module using the ADT name to look up information about constructors. For"
" example, if a constructor is being pattern-matched in a match expression "
"clause, the type-checker must check the constructor's signature to ensure "
"that any bound variables are being assigned the correct types."
msgstr ""

#: ../../_staging/langref/relay_type.rst:329
msgid ""
"See :py:class:`~tvm.relay.adt.TypeData` for its definition and "
"documentation."
msgstr ""

#: ../../_staging/langref/relay_type.rst:332
msgid "Type Call"
msgstr ""

#: ../../_staging/langref/relay_type.rst:334
msgid ""
"Because an ADT definition can take type parameters, Relay's type system "
"considers an ADT definition to be a *type-level function* (in that the "
"definition takes type parameters and returns the type of an ADT instance "
"with those type parameters). Thus, any instance of an ADT is typed using a "
"type call, which explicitly lists the type parameters given to the ADT "
"definition."
msgstr ""

#: ../../_staging/langref/relay_type.rst:341
msgid ""
"It is important to list the type parameters for an ADT instance, as two ADT "
"instances built using different constructors but the same type parameters "
"are of the *same type* while two ADT instances with different type "
"parameters should not be considered the same type (e.g., a list of integers "
"should not have the same type as a list of pairs of floating point tensors)."
msgstr ""

#: ../../_staging/langref/relay_type.rst:348
msgid ""
"The \"function\" in the type call is the ADT handle and there must be one "
"argument for each type parameter in the ADT definition. (An ADT definition "
"with no arguments means that any instance will have no type arguments passed"
" to the type call)."
msgstr ""

#: ../../_staging/langref/relay_type.rst:353
msgid ""
"See :py:class:`~tvm.relay.ty.TypeCall` for its definition and documentation."
msgstr ""

#: ../../_staging/langref/relay_type.rst:356
msgid "Example: List ADT"
msgstr ""

#: ../../_staging/langref/relay_type.rst:358
msgid ""
"This subsection uses the simple list ADT (included as a default ADT in "
"Relay) to illustrate the constructs described in the previous sections. Its "
"definition is as follows:"
msgstr ""

#: ../../_staging/langref/relay_type.rst:369
msgid ""
"Thus, the global type variable :code:`List` is the handle for the ADT. The "
"type data for the list ADT in the module notes that :code:`List` takes one "
"type parameter and has two constructors, :code:`Nil` (with signature "
":code:`fn<a>() -> List[a]`) and :code:`Cons` (with signature :code:`fn<a>(a,"
" List[a]) -> List[a]`). The recursive reference to :code:`List` in the "
":code:`Cons` constructor is accomplished by using the global type variable "
":code:`List` in the constructor definition."
msgstr ""

#: ../../_staging/langref/relay_type.rst:378
msgid "Below two instances of lists with their types given, using type calls:"
msgstr ""

#: ../../_staging/langref/relay_type.rst:385
msgid ""
"Note that :code:`Nil()` can be an instance of any list because it does not "
"take any arguments that use a type parameter. (Nevertheless, for any "
"*particular* instance of :code:`Nil()`, the type parameter must be "
"specified.)"
msgstr ""

#: ../../_staging/langref/relay_type.rst:390
msgid ""
"Here are two lists that are rejected by the type system because the type "
"parameters do not match:"
msgstr ""
