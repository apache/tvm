# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020 - 2021, Apache Software Foundation
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm 0.8.dev1734+gca660ba1e\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-12 10:06+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../_staging/arch/virtual_machine.rst:19
msgid "Putting the VM in TVM: The Relay Virtual Machine"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:21
msgid ""
"Relay, a new program representation, has enabled the representation and "
"optimization of a great breadth of machine learning programs. "
"Unfortunately, by supporting a more expressive set of programs, we have "
"introduced several new execution challenges."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:26
msgid ""
"Relay's interpreter can execute the full language but has notable "
"limitations that make it unsuited for production deployments. It is "
"structured as an inefficient interpreter that performs AST traversal to "
"execute the program. This approach is conceptually simple but "
"inefficient, as the AST traversal heavily relies on indirection."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:31
msgid ""
"There are further challenges in compiling dynamic code, such as dynamic "
"scheduling and allocation, fully dynamic tensor shapes, and control flow."
" The interpreter offers simple solutions for these, but none is "
"sufficiently compelling or optimized."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:35
msgid ""
"The second execution mechanism is the existing graph executor. In order "
"to target Relay programs to this, we compile a small subset of them to "
"the old graph format and execute them on the runtime. Graph executor "
"provides a fast execution experience but only for a very limited subset "
"of Relay programs."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:40
msgid ""
"An alternative but not-standard approach is Relay's ahead-of-time "
"compiler, which compiles a Relay program into a shared library containing"
" an ahead-of-time implementation. The ahead-of-time compiler provides "
"compelling performance but is difficult to extend and instrument, which "
"can only be done by modifying the code generation and optimization "
"mechanisms."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:46
msgid ""
"The Relay virtual machine is intended to be a framework that balances "
"these competing approaches, providing a dynamic execution environment "
"which can be extended, instrumented, and integrated with other approaches"
" like ahead-of-time compilation via a flexible extension mechanism."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:51
msgid ""
"The virtual machine is designed to strike a balance between performance "
"and flexibility when deploying and executing Relay programs, without "
"giving up the benefits of TVM."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:54
msgid ""
"Virtual machine (VM) design is a well-studied area in programming "
"languages and systems, and there have been various virtual machine "
"designs for both full-fledged and embedded programing languages. Previous"
" language VM designs have been heavily tailored to the execution profile "
"of traditional programs. Traditional programs manipulate small scalar "
"values and consist of a large number of low-level instructions. The sheer"
" quantity of instructions requires instruction execution and dispatch to "
"be extremely efficient. In the context of machine learning we manipulate "
"primarily tensor values, using a (relatively) low number of high level "
"instructions. ML programs' cost centers are expensive operator "
"invocations, such as GEMM or convolution, over a large input. Due to the "
"execution profile exhibited by ML programs, micro-optimizations present "
"in scalar VMs are dramatically less important."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:65
msgid ""
"TVM has provided strong support for vision models, but we want to grow to"
" support a wider variety of models. The graph executor is able to utilize"
" the fully static nature of the input graphs to perform aggressive "
"optimization such as fully static allocation, and optimal memory reuse. "
"When we introduce models which make use of control flow, recursion, "
"dynamic shapes, and dynamic allocation, we must change how execution "
"works. A virtual machine for Relay is a natural choice."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:72
msgid ""
"The rest of this document provides a high-level overview of the Relay "
"virtual machine design and its instruction set."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:76
msgid "Design"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:78
msgid ""
"The VM's design is focused on simplicity without sacrificing performance."
" In order to accomplish this we have focused on designing a tensor VM "
"rather than a scalar VM."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:81
msgid ""
"In the tensor VM setting, we optimize for cheap “allocation” of objects "
"(by trying to avoid real allocation), reuse of static fragments, and the "
"ability to do dynamic shape (i.e jagged tensors)."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:85
msgid "Instruction Set"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:87
msgid ""
"The choices of an instruction set and instruction representation are the "
"most critical design decisions for a VM. The current representation of "
"the instructions is a tagged union containing the op-code and the data "
"payload.  An important design decision is the level of abstraction of the"
" instructions (RISC vs. CISC) and how they take their data (fixed-width "
"instruction encoding vs. variable-length encoding). The current version "
"is closer to CISC, with complex instructions like AllocTensor, and is "
"variable-length due to the inclusion of the shape as part of the "
"instruction. The current instruction set is very high-level and "
"corresponds roughly to high-level operations in Relay."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:91
msgid "Ret"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:92
#: ../../_staging/arch/virtual_machine.rst:102
#: ../../_staging/arch/virtual_machine.rst:117
#: ../../_staging/arch/virtual_machine.rst:131
#: ../../_staging/arch/virtual_machine.rst:144
#: ../../_staging/arch/virtual_machine.rst:157
#: ../../_staging/arch/virtual_machine.rst:170
#: ../../_staging/arch/virtual_machine.rst:184
#: ../../_staging/arch/virtual_machine.rst:195
#: ../../_staging/arch/virtual_machine.rst:209
#: ../../_staging/arch/virtual_machine.rst:223
#: ../../_staging/arch/virtual_machine.rst:232
#: ../../_staging/arch/virtual_machine.rst:242
#: ../../_staging/arch/virtual_machine.rst:253
#: ../../_staging/arch/virtual_machine.rst:263
msgid "**Arguments**: ::"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:98
msgid "Returns the object in register ``result`` to caller's register ``dst``."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:101
msgid "InvokePacked"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:110
msgid ""
"Invoke the packed function denoted by ``packed_index``. The ``arity`` and"
" ``output_size`` are used to inform the VM how many inputs and outputs to"
" expect. ``packed_args`` stores the list of argument registers. Note "
"``Index`` is an alias of ``int64_t``, and it will be used in other "
"instructions as well."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:116
msgid "AllocTensor"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:126
msgid ""
"Allocate a tensor value of using constant shape (stored in ``shape``) and"
" ``dtype`` from the given storage block, ``storage``. The result is saved"
" to register ``dst``."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:130
msgid "AllocTensorReg"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:139
msgid ""
"Allocate a tensor value of the appropriate shape (stored in "
"``shape_register``) and ``dtype`` from the given storage block (stored in"
" ``storage``). The result is saved to register ``dst``."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:143
msgid "AllocStorage"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:152
msgid ""
"Allocate a storage block with the given ``size``, ``alignment`` and data "
"type, ``dtype_hint``. The allocated storage block is stored in register "
"``dst``."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:156
msgid "AllocADT"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:165
msgid ""
"Allocate a data type with the tag ``tag`` using the ``num_fields`` "
"entries from registers ``datatype_fields``. The result is saved to "
"register ``dst``."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:169
msgid "AllocClosure"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:178
msgid ""
"Allocate a closure with the VMFunction at ``clo_index`` as its code, and "
"the ``num_freevar`` entries from registers in ``free_vars``. The result "
"is saved to register ``dst``."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:183
msgid "GetField"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:191
msgid ""
"Get the field value with index ``field_index`` from ``object``. And saves"
" the result to register ``dst``."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:194
msgid "If"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:203
msgid ""
"Check if the object at register ``test`` is equal to ``target``. If "
"equal, relative jump by ``true_offset``, else relative jump by "
"``false_offset``."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:208
msgid "GetTag"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:215
msgid ""
"Get the object tag for ADT object in register ``object``. And saves the "
"reult to register ``dst``."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:218
msgid "Fatal"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:219
msgid "Fail the virtual machine execution."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:222
msgid "Goto"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:228
msgid "Relative unconditional jump by ``pc_offset``."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:231
msgid "Invoke"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:237
msgid ""
"Invoke function at ``func_index``, consumes the number of arguments "
"contained in the VMFunction's arity field."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:241
msgid "InvokeClosure"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:249
msgid ""
"Invokes ``closure``, consuming the number of arguments declared in the "
"closure's VMFunction."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:252
msgid "LoadConst"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:259
msgid ""
"Load the constant at ``const_index`` from the constant pool. The result "
"is saved to register ``dst``."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:262
msgid "LoadConsti"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:269
msgid ""
"Load the constant integer ``val`` to register ``dst``. The result is a "
"0-rank tensor."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:272
msgid "Object Representation"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:273
msgid ""
"We leverage the object protocol to represent the objects that are used by"
" the VM."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:276
msgid ""
"Currently, three types of objects, ``NDArray``, ``ADT``, and ``Closure`` "
"objects, are used to represent tensor, tuple/list, and closure data, "
"respectively. More details for each of them can be found at "
"`include/tvm/runtime/ndarray.h`_, `include/tvm/runtime/vm/vm.h`_, and "
"`include/tvm/runtime/container.h`_, respectively."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:288
msgid "Stack and State"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:290
msgid ""
"The Relay VM maintains a stack frame, which contains information about "
"how to resume the previous call. Registers are allocated in a continuous "
"space (virtual register file) for each function."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:293
msgid ""
"We keep track of a set of Relay functions we have called, a pointer into "
"its bytecode, an offset into the byte code (known as the program "
"counter)."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:312
msgid "Dispatch Loop"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:313
msgid ""
"A critical piece of a VM is the dispatch loop. The dispatch loop usually "
"dominates the execution time of a virtual machine, but we have "
"experimentally found this not to be the case for Relay. We have just "
"implemented a simple ``switch``/``goto`` dispatch loop which dispatches "
"based on instruction op code."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:317
msgid "This loop is implemented by ``VirtualMachine::Run()``."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:320
msgid "VM Compiler"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:322
msgid ""
"An important part of this infrastructure is a compiler from Relay's full "
"IR into a sequence of bytecode. The VM compiler transforms a "
"``tvm::relay::Module`` into a ``tvm::relay::vm::Executable``. The "
"executable contains a set of compiled functions, the compiled functions "
"are contained in ``tvm::relay::vm::Function``. The functions contain "
"metadata about the function as well as its compiled bytecode. The emitted"
" executable object then can be loaded and run by a "
"``tvm::relay::vm::VirtualMachine`` object. For full definitions of the "
"data structures, please see `include/tvm/runtime/vm/executable.h`_ and "
"`include/tvm/runtime/vm/vm.h`_."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:332
msgid "Optimizations"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:334
msgid ""
"There are quite a few optimizations required by the VM compiler. Each of "
"them is implemented as a pass which is managed by the Relay pass manager."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:337
msgid "Optimizations marked with `TODO` are not implemented yet."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:339
msgid "A-Normal Form"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:340
msgid "Lambda Lift (see `src/relay/vm/lambda_lift.cc`_)"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:341
msgid "Inline Primitives (see `src/relay/vm/inline_primitives.cc`_)"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:342
msgid "Constant Pool Layout (see `src/relay/backend/vm/compiler.cc`_)"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:343
msgid "Tail Call Optimization (TODO)"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:344
msgid "Liveness Analysis (TODO)"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:353
msgid "Serialization"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:355
msgid ""
"Serializing and deserializing the executable generated by the Relay VM "
"compiler is a must as we may want to save the model to the disk and "
"perform inference later. Previously, Relay has produced a serialized form"
" in a json file for the graph executor. However, the same format is not "
"directly applicable to the VM as it emits bytecode instead of graph-style"
" programs. Serialization of an executable essentially needs to handle "
"both model specific (i.e. weights and kernels) and VM related (i.e. "
"bytecode and global function names) data."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:362
msgid ""
"For kernels, we can conveniently leverage existing TVM infra to save and "
"load the compiled library module. Here we only focus on serializing other"
" several components in a binary format that is organized with the "
"following sections in order."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:366
msgid ""
"Global section. This section contains the globals (function names) used "
"by the virtual machine."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:368
msgid ""
"Constant section. This section is used to store the constant pool (i.e. "
"weights of the model) for a virtual machine."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:371
msgid ""
"Primitive name section. This section is introduced to accommodate the "
"list of primitive operator names that will be invoked by the virtual "
"machine, i.e. the names starting with ``fused_``. The primitive names are"
" used as symbols to look up function pointers in the compiled kernel "
"library."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:376
msgid ""
"Code section. The VM functions, including bytecode, are sitting in this "
"section. The dispatching loop iterates through this section to fetch "
"instructions for execution."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:379
msgid ""
"Hence, unlike the graph executor artifact that contains weight (.params),"
" graph json (.json), and compiled kernel library (.so), the serialized "
"executable artifact is composed of the Relay object file (.ro) and the "
"compiled kernel library (.so)."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:383
msgid ""
"A ``save`` function is implemented to store the executable to the disk "
"and serialize it into the above format. Meanwhile, a ``load_exec`` "
"function is used to load the serialized kernel binary and executable "
"related binary code, which will be again used to instantiate a VM object."
" Please refer to the `test_vm_serialization.py`_ file for more examples."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:392
msgid "Unresolved Questions"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:395
msgid "How do we handle dynamic shapes?"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:397
msgid ""
"Dynamic shape support is ongoing work in TVM as we upgrade Relay, TVM's "
"compiler.  For the most recent updates on dynamic shape support, we "
"recommend following updates in TVM's Discuss forum "
"(https://discuss.tvm.apache.org/)."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:401
msgid "How can we modify the VM to support JIT compilation of certain code paths?"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:403
msgid ""
"In the code generation space there are still many tradeoffs to be "
"analyzed and the VM is designed to be very flexible so we can modify it "
"for future experiments."
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:407
msgid "How do we support heterogenous execution?"
msgstr ""

#: ../../_staging/arch/virtual_machine.rst:409
msgid ""
"Heterogenous execution should work out of the box assuming we have "
"annotated the appropriate device copies. In order to do this properly we "
"need to run the device annotation and copying passes."
msgstr ""

