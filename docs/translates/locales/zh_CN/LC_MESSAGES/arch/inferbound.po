# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2020 - 2021, Apache Software Foundation
# This file is distributed under the same license as the tvm package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
# 
# Translators:
# baijie xie, 2021
# minggui wang, 2021
# 
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: tvm 0.8.dev1734+gca660ba1e\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-10-12 10:06+0000\n"
"PO-Revision-Date: 2021-10-13 01:29+0000\n"
"Last-Translator: minggui wang, 2021\n"
"Language-Team: Chinese (China) (https://www.transifex.com/TVMChinese/teams/124815/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../_staging/arch/inferbound.rst:22
msgid "InferBound Pass"
msgstr "InferBound Pass"

#: ../../_staging/arch/inferbound.rst:25
msgid ""
"The InferBound pass is run after normalize, and before ScheduleOps "
"`build_module.py "
"<https://github.com/apache/tvm/blob/main/python/tvm/driver/build_module.py>`_."
" The main job of InferBound is to create the bounds map, which specifies a "
"Range for each IterVar in the program. These bounds are then passed to "
"ScheduleOps, where they are used to set the extents of For loops, see "
"`MakeLoopNest "
"<https://github.com/apache/tvm/blob/main/src/te/operation/op_util.cc>`_, and"
" to set the sizes of allocated buffers (`BuildRealize "
"<https://github.com/apache/tvm/blob/main/src/te/operation/compute_op.cc>`_),"
" among other uses."
msgstr ""
"InferBound在normalize之后、ScheduleOps之前发生 `build_module.py "
"<https://github.com/apache/tvm/blob/main/python/tvm/driver/build_module.py>`_。"
" "
"它的主要作用是创建边界（bound）的映射表，记录程序中每一个循环变量（IterVar）的范围。这些边界在ScheduleOps中，用于设置For循环节点的extent域，"
" 参考 `MakeLoopNest "
"<https://github.com/apache/tvm/blob/main/src/te/operation/op_util.cc>`_, "
"以及用于设置缓存（buffer）的大小 (`BuildRealize "
"<https://github.com/apache/tvm/blob/main/src/te/operation/compute_op.cc>`_),"
" 等等。"

#: ../../_staging/arch/inferbound.rst:27
msgid "The output of InferBound is a map from IterVar to Range:"
msgstr "InferBound的输出是一个从循环变量（IterVar）到其范围（Range）的映射表："

#: ../../_staging/arch/inferbound.rst:33
msgid "Therefore, let's review the Range and IterVar classes:"
msgstr "因此，让我们回顾一下 Range 和 IterVar 类："

#: ../../_staging/arch/inferbound.rst:56
msgid ""
"Note that IterVarNode also contains a Range ``dom``. This ``dom`` may or may"
" not have a meaningful value, depending on when the IterVar was created. For"
" example, when ``tvm.compute`` is called, an `IterVar is created "
"<https://github.com/apache/tvm/blob/main/src/te/operation/compute_op.cc>`_ "
"for each axis and reduce axis, with dom's equal to the shape supplied in the"
" call to ``tvm.compute``."
msgstr ""
"请注意，IterVarNode 还包含一个Range ``dom`` 成员变量。此 ``dom``  可能有或可能没有有意义的值，具体取决于 "
"IterVar 的创建时间。例如，当调用 ``tvm.compute`` "
"时，会为每个空间轴和规约轴`创建一个IterVar<https://github.com/apache/tvm/blob/main/src/te/operation/compute_op.cc>`"
" ，这时dom也就等于调用 ``tvm.compute`` 时所提供的形状（shape）。"

#: ../../_staging/arch/inferbound.rst:58
msgid ""
"On the other hand, when ``tvm.split`` is called, `IterVars are created "
"<https://github.com/apache/tvm/blob/main/src/te/schedule/schedule_lang.cc>`_"
" for the inner and outer axes, but these IterVars are not given a meaningful"
" ``dom`` value."
msgstr ""
"另一方面，当 ``tvm.split`` 被调用时，会`为内部轴和外部轴创建 "
"IterVar<https://github.com/apache/tvm/blob/main/src/te/schedule/schedule_lang.cc>`"
" ，但并没有给这些 IterVar 赋予有意义的 ``dom`` 值。"

#: ../../_staging/arch/inferbound.rst:60
msgid ""
"In any case, the ``dom`` member of an IterVar is never modified during "
"InferBound. However, keep in mind that the ``dom`` member of an IterVar is "
"sometimes used as default value for the Ranges InferBound computes."
msgstr ""
"在任何情况下，IterVar 的 ``dom`` 成员变量在 InferBound 期间都不会被修改。但是，请记住，IterVar 的 ``dom`` "
"成员变量有时用作范围（Ranges）计算的默认值。"

#: ../../_staging/arch/inferbound.rst:62
msgid ""
"We next review some TVM codebase concepts that are required to understand "
"the InferBound pass."
msgstr "为了理解 InferBound pass，接下来我们将回顾一些 TVM 代码库的概念。"

#: ../../_staging/arch/inferbound.rst:64
msgid ""
"Recall that InferBound takes one argument, a Schedule. This schedule object,"
" and its members, contains all information about the program being compiled."
msgstr ""
"回想一下， InferBound 需要一个 Schedule 引用类型的参数。这个 schedule 对象及其成员包含了有关正在编译的程序的所有信息。"

#: ../../_staging/arch/inferbound.rst:66
msgid ""
"A TVM schedule is composed of Stages. Each stage has exactly one Operation, "
"e.g., a ComputeOp or a TensorComputeOp. Each operation has a list of "
"root_iter_vars, which in the case of ComputeOp, are composed of the axis "
"IterVars and the reduce axis IterVars. Each operation can also contain many "
"other IterVars, but all of them are related by the operations's list of "
"IterVarRelations. Each IterVarRelation represents either a split, fuse or "
"rebase in the schedule. For example, in the case of split, the "
"IterVarRelation specifies the parent IterVar that was split, and the two "
"children IterVars: inner and outer."
msgstr ""
"TVM schedule 由阶段（Stage）组成。每个阶段只有一个操作（Operation），例如 ComputeOp 或 "
"TensorComputeOp 。而每个操作都有一个 root_iter_vars 列表，在 ComputeOp 的情况下，该列表由轴循环变量（axis"
" IterVars）和规约轴循环变量（reduce "
"IterVars）组成。每个操作还可以包含许多其他循环变量（IterVar），但这些循环变量都会由操作的 IterVarRelations "
"列表相关联。每个 IterVarRelation 表示 schedule "
"中的拆分（split）、融合（fuse）或变基（rebase）。例如，在拆分的情况下，IterVarRelation "
"指定了被拆分的父循环变量（parent IterVar）和两个子循环变量（children IterVar）：内部循环变量和外部循环变量。"

#: ../../_staging/arch/inferbound.rst:107
msgid ""
"Tensors haven't been mentioned yet, but in the context of TVM, a Tensor "
"represents output of an operation."
msgstr "至此还未提及张量（Tensor），但在 TVM 中，张量表示一个操作（Operation）输出。"

#: ../../_staging/arch/inferbound.rst:120
msgid ""
"In the Operation class declaration above, we can see that each operation "
"also has a list of InputTensors. Thus the stages of the schedule form a DAG,"
" where each stage is a node in the graph. There is an edge in the graph from"
" Stage A to Stage B, if the operation of Stage B has an input tensor whose "
"source operation is the op of Stage A. Put simply, there is an edge from A "
"to B, if B consumes a tensor produced by A. See the diagram below. This "
"graph is created at the beginning of InferBound, by a call to "
"`CreateReadGraph "
"<https://github.com/apache/tvm/blob/main/src/te/schedule/bound.cc>`_."
msgstr ""
"在上面的 Operation 类声明中，我们可以看到每个操作都有一个 InputTensor 列表。因此，schedule "
"的所有阶段形成了一张有向无环图（DAG），其中每个阶段就是图中的节点。如果阶段 B 的操作有一个输入张量，其源操作是阶段 A 中的操作，则从阶段 A "
"到阶段 B 存在一条边。 简单地说，如果 B 消耗 A 产生的张量，则从 A 到 B 有一条边。请参阅下面的图。在InferBound的开头通过调用 "
"`CreateReadGraph "
"<https://github.com/apache/tvm/blob/main/src/te/schedule/bound.cc>` 创建了这张图。"

#: ../../_staging/arch/inferbound.rst:125
msgid ""
"InferBound makes one pass through the graph, visiting each stage exactly "
"once. InferBound starts from the output stages (i.e., the solid blue nodes "
"in the graph above), and moves upwards (in the opposite direction of the "
"edges). This is achieved by performing a reverse topological sort on the "
"nodes of the graph. Therefore, when InferBound visits a stage, each of its "
"consumer stages has already been visited."
msgstr ""
"InferBound 遍历一次图，每个阶段正好访问一次。InferBound "
"从输出阶段开始（即上图中的蓝色实心节点），然后向上移动（延着边的相反方向）。这是通过对图的节点执行反向拓扑排序来实现的。因此，当 InferBound "
"访问一个阶段时，其每个消费者阶段就已经被访问了。"

#: ../../_staging/arch/inferbound.rst:130
msgid "The InferBound pass is shown in the following pseudo-code:"
msgstr "InferBound pass 的伪代码如下所示："

#: ../../_staging/arch/inferbound.rst:146
msgid ""
"The InferBound pass has two interesting properties that are not immediately "
"obvious:"
msgstr "InferBound pass 有两个有趣的属性，不是明显："

#: ../../_staging/arch/inferbound.rst:148
msgid ""
"After InferBound visits a stage, the ranges of all IterVars in the stage "
"will be set in ``rmap``."
msgstr "在 InferBound 访问一个 stage 后，该 stage 中所有 IterVars 的范围将被设置在 ``rmap`` 中。"

#: ../../_staging/arch/inferbound.rst:149
msgid ""
"The Range of each IterVar is only set once in ``rmap``, and then never "
"changed."
msgstr "每个 IterVar 的范围只在 ``rmap`` 中设置一次，然后永远不会改变。"

#: ../../_staging/arch/inferbound.rst:151
msgid ""
"So it remains to explain what InferBound does when it visits a stage. As can"
" be seen in the pseudo-code above, InferBound calls two functions on each "
"stage: InferRootBound, and PassDownDomain. The purpose of InferRootBound is "
"to set the Range (in ``rmap``) of each root_iter_var of the stage. (Note: "
"InferRootBound does not set the Range of any other IterVar, only those "
"belonging to root_iter_vars). The purpose of PassDownDomain is to propagate "
"this information to the rest of the stage's IterVars.  When PassDownDomain "
"returns, all IterVars of the stage have known Ranges in ``rmap``."
msgstr ""
"因此，有必要解释下 InferBound 在访问一个阶段时的作用。如上文的伪代码所示，InferBound "
"在每个阶段调用两个函数：InferRootBound 和 PassDownDomain。InferRootBound 的目的是设置该阶段的每个 "
"root_iter_var 的 Range（在 ``rmap`` 中）。（注：InferRootBound 不会设置其他任何 IterVar 的 "
"Range，而只会设置属于 root_iter_vars 的 IterVar Range）。PassDownDomain "
"的目的是将该信息传播到阶段的其余 IterVar。当 PassDownDomain 返回时， 阶段中的所有 IterVar 在 ``rmap`` "
"都有对应的 Range。"

#: ../../_staging/arch/inferbound.rst:153
msgid ""
"The remainder of the document dives into the details of InferRootBound and "
"PassDownDomain. Since PassDownDomain is simpler to describe, we will cover "
"it first."
msgstr ""
"该文档的其余部分深入探讨了 InferRootBound 和 PassDownDomain 的细节。由于 PassDownDomain "
"更易于描述，我们将先介绍它。"

#: ../../_staging/arch/inferbound.rst:158
msgid "IterVar Hyper-graph"
msgstr "IterVar 超图"

#: ../../_staging/arch/inferbound.rst:160
msgid ""
"The InferBound pass traverses the stage graph, as described above. However, "
"within each stage is another graph, whose nodes are IterVars. InferRootBound"
" and PassDownDomain perform message-passing on these IterVar graphs."
msgstr ""
"如上所述，InferBound pass 遍历了由阶段组成的图。但是，在每个阶段中都有另外一张图，其节点都是 "
"IterVar。InferRootBound 和 PassDownDomain 在这些 IterVar 图上执行消息的传递。"

#: ../../_staging/arch/inferbound.rst:162
msgid ""
"Recall that all IterVars of the stage are related by IterVarRelations. The "
"IterVarRelations of a stage form a directed acyclic hyper-graph, where each "
"node of the graph corresponds to an IterVar, and each hyper-edge corresponds"
" to an IterVarRelation. We can also represent this hyper-graph as a DAG, "
"which is simpler to visualize as shown below."
msgstr ""
"回想一下，该阶段的所有 IterVar 都与 IterVarRelation 相关。阶段的 IterVarRelation "
"形成了有向无环超图，其中图的每个节点对应一个 IterVar，超图的每条边对应于一个 IterVarRelation。我们还可以将此超图表示为 "
"DAG，这样更易于可视化，如下图所示。"

#: ../../_staging/arch/inferbound.rst:168
msgid ""
"The above diagram shows the IterVar hyper-graph for one stage. The stage has"
" one root_iter_var, ``i``. It has been split, and the resulting inner axis "
"``i.inner``, has been split again. The leaf_iter_vars of the stage are shown"
" in green: ``i.outer``, ``i.inner.outer``, and ``i.inner.inner``."
msgstr ""
"上图显示了一个阶段的 IterVar 超图。该阶段有一个 root_iter_var，``i``。它已经被拆分，并且由此产生的内轴 "
"``i.inner`` 再次被拆分。该阶段的 leaf_iter_var 用绿色表示：``i.outer``，``i.inner.outer`` 和 "
"``i.inner.inner``。"

#: ../../_staging/arch/inferbound.rst:170
msgid ""
"Message passing functions are named \"PassUp\" or \"PassDown\", depending on"
" whether messages are passed from children to their parent in the DAG "
"(\"PassUp\"), or from the parent to its children (\"PassDown\"). For "
"example, the large arrow on the left-hand side of the diagram above, shows "
"that PassDownDomain sends messages from the root IterVar ``i`` to its "
"children ``i.outer`` and ``i.inner``."
msgstr ""
"消息传递函数的名称为 \"PassUp\" 或 \"PassDown\"，具体取决于消息是从子节点传递到 DAG "
"中的父节点（\"PassUp\"），还是从父节点传递给其子节点（\"PassDown\"）。例如，上图左侧的大箭头表明 PassDownDomain "
"会从根 IterVar ``i`` 向其子节点 ``i.outer`` 和 ``i.inner`` 发送消息。"

#: ../../_staging/arch/inferbound.rst:175
msgid "PassDownDomain"
msgstr "PassDownDomain"

#: ../../_staging/arch/inferbound.rst:176
msgid ""
"The purpose of PassDownDomain is to take the Ranges produced by "
"InferRootBound for the root_iter_vars, and set the Ranges of all other "
"IterVars in the stage."
msgstr ""
"PassDownDomain 的目的是获取 InferRootBound 为 root_iter_var 产生的 Range ，并为阶段中所有其他  "
"IterVar 设置 Range。"

#: ../../_staging/arch/inferbound.rst:178
msgid ""
"PassDownDomain iterates through the stage's IterVarRelations. There are "
"three possible types of IterVarRelation: split, fuse, and rebase. The most "
"interesting case (since it offers opportunity for improvement), is "
"IterVarRelations representing splits."
msgstr ""
"PassDownDomain 会遍历阶段的 IterVarRelation。IterVarRelation "
"有三种可能的类型：拆分、融合和变基。而最有趣的类型（因为它提供了改进的机会）是表示拆分的 IterVarRelation。"

#: ../../_staging/arch/inferbound.rst:180
msgid ""
"The Ranges of the inner and outer IterVars of the split are set based on the"
" parent IterVar's known Range, as follows:"
msgstr "拆分的内部 IterVar 和外部 IterVar 的 Range 是根据父 IterVar 的已知 Range 来设置的，如下所示："

#: ../../_staging/arch/inferbound.rst:187
msgid ""
"There is an opportunity here to tighten the bounds produced by InferBound, "
"when ``split->factor`` does not evenly divide the parent's extent. Suppose "
"the parent's extent is 20, and the split factor is 16. Then on the second "
"iteration of the outer loop, the inner loop only needs to perform 4 "
"iterations, not 16. If PassDownDomain could set the extent of "
"``split->inner`` to ``min(split->factor, rmap[split->parent]->extent - "
"(split->outer * split->factor))``, then the extent of the inner variable "
"would properly adapt, based on which iteration of the outer loop is being "
"executed."
msgstr ""
"当 ``split->factor`` 没有均匀地划分父级的范围（extent）时，就有机会收紧 InferBound 产生的边界。假设父级的范围是 "
"20，拆分系数是 16。然后在外循环的第二次迭代中，内循环只需要执行 4 次迭代，而不是 16 次迭代。如果 PassDownDomain 能够将 "
"``split->inner`` 的范围设置为 ``min(split->factor, rmap[split->parent]->extent - "
"(split->outer * split->factor))`` ，那么内部变量的范围将根据正在执行的外循环的迭代进行适当的调整。"

#: ../../_staging/arch/inferbound.rst:189
msgid ""
"For Fuse relations, the Range of the fused IterVar is set based on the known"
" Ranges of the inner and outer IterVars, as follows:"
msgstr ""
"对于融合类型的关系，融合IterVar 的 Range 是根据内部 IterVar  和外部 IterVar 的已知 Range 来设置的，如下所示："

#: ../../_staging/arch/inferbound.rst:197
msgid "InferRootBound"
msgstr "InferRootBound"

#: ../../_staging/arch/inferbound.rst:199
msgid ""
"Recall that InferBound calls InferRootBound, followed by "
":ref:`PassDownDomain` on each stage in the stage graph. The purpose of "
"InferRootBound is to set the Range of each root_iter_var of the Stage's "
"operation. These Ranges will be propagated to the rest of the stage's "
"IterVars using :ref:`PassDownDomain`. Note that InferRootBound does not set "
"the Range of any other IterVar, only those belonging to the stage's "
"root_iter_vars."
msgstr ""
"回想一下， InferBound 调用了 InferRootBound，然后在阶段图中的每个阶段调用 :ref:`PassDownDomain` "
"。InferRootBound 的目的是设置阶段的操作(operation)的每个 root_iter_var 范围。这些范围将使用 "
":ref:`PassDownDomain`  被传播到阶段的其余 IterVars。请注意，InferRootBound 不会设置任何其他 "
"IterVar 的范围，而只会设置那些属于该阶段的 root_iter_vars。"

#: ../../_staging/arch/inferbound.rst:201
msgid ""
"If the stage is an output stage or placeholder, InferRootBound simply sets "
"the root_iter_var Ranges to their default values. The default Range for a "
"root_iter_var is taken from the ``dom`` member of the IterVar (see the "
"IterVarNode class declaration above)."
msgstr ""

#: ../../_staging/arch/inferbound.rst:203
msgid ""
"Otherwise, InferRootBound iterates through the consumers of the stage. "
"IntSets are created for each of the consumer's IterVars, as follows. Phase "
"1) IntSets are initialized for the consumer's leaf_iter_vars, and propagated"
" to the consumer's root_iter_vars by PassUpDomain (Phase 2). These IntSets "
"are used to create TensorDom of the input tensors of the consumer stage "
"(Phase 3). Finally, once all of the consumers have been processed, "
"InferRootBound calls GatherBound, to set the Ranges of the stage's "
"root_iter_vars, based on the TensorDoms (Phase 4)."
msgstr ""

#: ../../_staging/arch/inferbound.rst:205
msgid ""
"This process can seem complicated. One reason is that a stage can have more "
"than one consumer. Each consumer has different requirements, and these must "
"somehow be consolidated. Similarly, the stage may output more than one "
"tensor, and each consumer only uses a particular subset of these tensors. "
"Furthermore, even if a consumer uses a particular tensor, it may not use all"
" elements of the tensor."
msgstr ""

#: ../../_staging/arch/inferbound.rst:207
msgid ""
"As mentioned above, a consumer may only require a small number of elements "
"from each tensor. The consumers can be thought of as making requests to the "
"stage, for certain regions of its output tensors. The job of Phases 1-3 is "
"to establish the regions of each output tensor that are required by each "
"consumer."
msgstr ""

#: ../../_staging/arch/inferbound.rst:213
msgid "IntSets"
msgstr ""

#: ../../_staging/arch/inferbound.rst:215
msgid ""
"During InferRootBound, Ranges are converted to IntSets, and message passing "
"is performed over IntSets. Therefore, it is important to understand the "
"difference between Ranges and IntSets. The name \"IntSet\" suggests it can "
"represent an arbitrary set of integers, e.g., A = \\{-10, 0, 10, 12, 13\\}. "
"This would certainly be more expressive than a Range, which only represents "
"a set of contiguous integers, e.g., B = \\{10,11,12\\}."
msgstr ""

#: ../../_staging/arch/inferbound.rst:217
msgid ""
"However, currently IntSets come in only three varieties: IntervalSets, "
"StrideSets, and ModularSets. IntervalSets, similarly to Ranges, only "
"represent sets of contiguous integers. A StrideSet is defined by a base "
"IntervalSet, a list of strides, and a list of extents. However, StrideSet is"
" unused, and ModularSet is only used by the frontend."
msgstr ""

#: ../../_staging/arch/inferbound.rst:219
msgid ""
"Therefore, not all sets of integers can be represented by an IntSet in TVM "
"currently. For example, set A in the example above can not be represented by"
" an IntSet. However, in future the functionality of IntSet can be extended "
"to handle more general kinds of integer sets, without requiring modification"
" to users of IntSet."
msgstr ""

#: ../../_staging/arch/inferbound.rst:221
msgid ""
"*InferBound is more complicated for schedules that contain compute_at. "
"Therefore, we first explain InferBound for schedules that do not contain "
"compute_at.*"
msgstr ""

#: ../../_staging/arch/inferbound.rst:226
#: ../../_staging/arch/inferbound.rst:553
msgid "Phase 1: Initialize IntSets for consumer's leaf_iter_vars"
msgstr ""

#: ../../_staging/arch/inferbound.rst:235
msgid ""
"In Phase 1, IntSets for each of the consumer's leaf_iter_vars are created, "
"based on the Ranges of the leaf_iter_vars from ``rmap``.  Recall that the "
"consumer has already been visited by InferBound, so all of its IterVars have"
" known Ranges in ``rmap``."
msgstr ""

#: ../../_staging/arch/inferbound.rst:237
#: ../../_staging/arch/inferbound.rst:564
msgid "There are three cases:"
msgstr "有以下三种情况："

#: ../../_staging/arch/inferbound.rst:239
#: ../../_staging/arch/inferbound.rst:566
msgid ""
"Case 1: Extent of leaf var's Range is 1. In this case, the up_state for the "
"leaf is just a single point, equal to the Range's min."
msgstr ""

#: ../../_staging/arch/inferbound.rst:240
msgid ""
"Case 2: *No relaxation is needed. In this case, the up_state for the leaf is"
" just a single point, defined by the leaf var itself.*"
msgstr ""

#: ../../_staging/arch/inferbound.rst:241
#: ../../_staging/arch/inferbound.rst:568
msgid ""
"Case 3: Relaxation is needed. In this case, the leaf's Range is simply "
"converted to an IntSet."
msgstr ""

#: ../../_staging/arch/inferbound.rst:243
msgid ""
"For simplicity, we assume the schedule does not contain thread axes. In this"
" case, Case 2 is only relevant if the schedule contains compute_at. Please "
"refer to the section :ref:`InferBoundCA`, for further explanation."
msgstr ""

#: ../../_staging/arch/inferbound.rst:248
#: ../../_staging/arch/inferbound.rst:575
msgid "Phase 2: Propagate IntSets from consumer's leaves to consumer's roots"
msgstr ""

#: ../../_staging/arch/inferbound.rst:257
msgid ""
"The purpose of Phase 2 is to propagate the IntSet information from the "
"consumer's leaf_iter_vars to the consumer's root_iter_vars. The result of "
"Phase 2 is another map, ``dom_map``, that contains an IntSet for each of the"
" consumer's root_iter_vars."
msgstr ""

#: ../../_staging/arch/inferbound.rst:259
#: ../../_staging/arch/inferbound.rst:584
msgid ""
"Phase 2 begins by calling PassUpDomain, which visits the IterVarRelations of"
" the consumer stage. In the case of a Split relation, PassUpDomain sets the "
"up_state of the parent IterVar, based on the inner and outer IntSets, as "
"follows:"
msgstr ""

#: ../../_staging/arch/inferbound.rst:261
#: ../../_staging/arch/inferbound.rst:586
msgid ""
"Case 1: The Ranges of outer and inner IterVars match their ``up_state`` "
"domains. In this case, set the parent's ``up_state`` by simply converting "
"the parent's Range to an IntSet."
msgstr ""

#: ../../_staging/arch/inferbound.rst:262
msgid ""
"Case 2: *Otherwise, the parent's* ``up_state`` *is defined by evaluating* "
"``outer*f + inner + rmap[parent]->min``, *with respect to the* ``up_state`` "
"*of outer and inner. Here, instead of using the Split relation's factor, TVM"
" uses* ``f = rmap[inner]->extent``."
msgstr ""

#: ../../_staging/arch/inferbound.rst:264
msgid ""
"Case 2 is only needed if the schedule contains compute_at. Please refer to "
"the section :ref:`InferBoundCA` below, for further explanation."
msgstr ""

#: ../../_staging/arch/inferbound.rst:266
msgid ""
"After PassUpDomain has finished propagating up_state to all IterVars of the "
"consumer, a fresh map, from root_iter_vars to IntSet, is created. If the "
"schedule does not contain compute_at, the IntSet for root_iter_var ``iv`` is"
" created by the following code:"
msgstr ""

#: ../../_staging/arch/inferbound.rst:272
msgid ""
"Note that if the schedule does not contain compute_at, Phases 1-2 are "
"actually unnecessary. dom_map can be built directly from the known Ranges in"
" rmap. Ranges simply need to be converted to IntSets, which involves no loss"
" of information."
msgstr ""

#: ../../_staging/arch/inferbound.rst:277
msgid "Phase 3: Propagate IntSets to consumer's input tensors"
msgstr ""

#: ../../_staging/arch/inferbound.rst:286
msgid ""
"Note that the consumer's input tensors are output tensors of the stage "
"InferBound is working on. So by establishing information about the "
"consumer's input tensors, we actually obtain information about the stage's "
"output tensors too: the consumers require certain regions of these tensors "
"to be computed. This information can then be propagated through the rest of "
"the stage, eventually obtaining Ranges for the stage's root_iter_vars by the"
" end of Phase 4."
msgstr ""

#: ../../_staging/arch/inferbound.rst:288
msgid ""
"The output of Phase 3 is tmap, which is a map containing all of the stage's "
"output tensors. Recall that a Tensor is multi-dimensional, with a number of "
"different axes. For each output tensor, and each of that tensor's axes, tmap"
" contains a list of IntSets. Each IntSet in the list is a request from a "
"different consumer."
msgstr ""

#: ../../_staging/arch/inferbound.rst:290
msgid ""
"Phase 3 is accomplished by calling PropBoundToInputs on the consumer. "
"PropBoundToInputs adds IntSets to tmap's lists, for all input Tensors of the"
" consumer."
msgstr ""

#: ../../_staging/arch/inferbound.rst:292
msgid ""
"The exact behavior of PropBoundToInputs depends on the type of the "
"consumer's operation: ComputeOp, TensorComputeOp, PlaceholderOp, ExternOp, "
"etc. Consider the case of TensorComputeOp. A TensorComputeOp already has a "
"Region for each of its Tensor inputs, defining the slice of the tensor that "
"the operation depends on. For each input tensor i, and dimension j, a "
"request is added to tmap, based on the corresponding dimension in the "
"Region:"
msgstr ""

#: ../../_staging/arch/inferbound.rst:304
msgid "Phase 4: Consolidate across all consumers"
msgstr ""

#: ../../_staging/arch/inferbound.rst:313
msgid ""
"Phase 4 is performed by GatherBound, whose behavior depends on the type of "
"operation of the stage. We discuss the ComputeOp case only, but "
"TensorComputeOp is the same."
msgstr ""

#: ../../_staging/arch/inferbound.rst:315
msgid ""
"A ComputeOp has only a single output Tensor, whose axes correspond to the "
"axis variables of the ComputeOp. The root_iter_vars of a ComputeOp include "
"these axis variables, as well as the reduce_axis variables. If the root "
"IterVar is an axis var, it corresponds to one of the axes of the output "
"Tensor. GatherBound sets the Range of such a root IterVar to the union of "
"all IntSets (i.e., union of all consumer requests) for the corresponding "
"axis of the tensor. If the root IterVar is a reduce_axis, its Range is just "
"set to its default (i.e., the ``dom`` member of IterVarNode)."
msgstr ""

#: ../../_staging/arch/inferbound.rst:327
msgid ""
"The union of IntSets is computed by converting each IntSet to an Interval, "
"and then taking the minimum of all minimums, and the maximum of all of these"
" interval's maximums."
msgstr ""

#: ../../_staging/arch/inferbound.rst:333
msgid ""
"This clearly results in some unnecessary computation, i.e., tensor elements "
"will be computed that are never used."
msgstr ""

#: ../../_staging/arch/inferbound.rst:335
msgid ""
"Unfortunately, even if we're lucky and the IntervalSet unions do not produce"
" unnecessary computation, the fact that GatherBound considers each dimension"
" of the tensor separately can also cause unnecessary computation. For "
"example, in the diagram below the two consumers A and B require disjoint "
"regions of the 2D tensor: consumer A requires T[0:2, 0:2], and consumer B "
"requires T[2:4, 2:4]. GatherBound operates on each dimension of the tensor "
"separately. For the first dimension of the tensor, GatherBound takes the "
"union of intervals 0:2 and 2:4, producing 0:4 (note that no approximation "
"was required here). Similarly for the second dimension of the tensor. "
"Therefore, the dimension-wise union of these two requests is T[0:4, 0:4]. So"
" GatherBound will cause all 16 elements of tensor T to be computed, even "
"though only half of those elements will ever be used."
msgstr ""

#: ../../_staging/arch/inferbound.rst:344
#: ../../_staging/arch/inferbound.rst:542
msgid "InferBound with compute_at"
msgstr ""

#: ../../_staging/arch/inferbound.rst:346
msgid ""
"If the schedule contains compute_at, Phases 1-2 of InferRootBound become "
"more complex."
msgstr ""

#: ../../_staging/arch/inferbound.rst:349
msgid "Motivation"
msgstr ""

#: ../../_staging/arch/inferbound.rst:351
msgid "**Ex. 1**"
msgstr ""

#: ../../_staging/arch/inferbound.rst:353
msgid "Consider the following snippet of a TVM program:"
msgstr ""

#: ../../_staging/arch/inferbound.rst:360
msgid "This produces the following (simplified IR):"
msgstr ""

#: ../../_staging/arch/inferbound.rst:371
msgid ""
"It's easy to see that stage D requires all (5,16) elements of C to be "
"computed."
msgstr ""

#: ../../_staging/arch/inferbound.rst:373
msgid "**Ex. 2**"
msgstr ""

#: ../../_staging/arch/inferbound.rst:375
msgid "However, suppose C is computed at axis j of D:"
msgstr ""

#: ../../_staging/arch/inferbound.rst:382
msgid "Then only a single element of C is needed at a time:"
msgstr ""

#: ../../_staging/arch/inferbound.rst:391
msgid "**Ex. 3**"
msgstr ""

#: ../../_staging/arch/inferbound.rst:393
msgid ""
"Similarly, if C is computed at axis i of D, only a vector of 16 elements of "
"C are needed at a time:"
msgstr ""

#: ../../_staging/arch/inferbound.rst:403
msgid ""
"Based on the above examples, it is clear that InferBound should give "
"different answers for stage C depending on where in its consumer D it is "
"\"attached\"."
msgstr ""

#: ../../_staging/arch/inferbound.rst:408
msgid "Attach Paths"
msgstr ""

#: ../../_staging/arch/inferbound.rst:410
msgid ""
"If stage C is computed at axis j of stage D, we say that C is  *attached*  "
"to axis j of stage D. This is reflected in the Stage object by setting the "
"following three member variables:"
msgstr ""

#: ../../_staging/arch/inferbound.rst:431
msgid ""
"Consider the above examples again. In order for InferBound to determine how "
"many elements of C must be computed, it is important to know whether the "
"computation of C occurs within the scope of a leaf variable of D, or above "
"that scope. For example, in Ex. 1, the computation of C occurs  *above*  the"
" scopes of all of D's leaf variables. In Ex. 2, the computation of C occurs"
"  *within*  the scope of all of D's leaf variables. In Ex. 3, C occurs "
"within the scope of D's i, but above the scope of D's j."
msgstr ""

#: ../../_staging/arch/inferbound.rst:433
msgid ""
"CreateAttachPath is responsible for figuring out which scopes contain a "
"stage C. These scopes are ordered from innermost scope to outermost. Thus "
"for each stage CreateAttachPath produces an \"attach path\", which lists the"
" scopes containing the stage, from innermost to outermost scope. In Ex. 1, "
"the attach path of C is empty. In Ex. 2, the attach path of C contains {j, "
"i}. In Ex. 3, the attach path of C is {i}."
msgstr ""

#: ../../_staging/arch/inferbound.rst:435
msgid ""
"The following example clarifies the concept of an attach path, for a more "
"complicated case."
msgstr ""

#: ../../_staging/arch/inferbound.rst:437
msgid "**Ex. 4**"
msgstr ""

#: ../../_staging/arch/inferbound.rst:446
msgid ""
"Here is the IR after ScheduleOps (note that loops with extent 1 have been "
"preserved, using the ``debug_keep_trivial_loop`` argument of ScheduleOps):"
msgstr ""

#: ../../_staging/arch/inferbound.rst:471
msgid ""
"In this case, the attach path of C is {dk, dj, di}. Note that C does not use"
" di, but di still appears in C's attach path."
msgstr ""

#: ../../_staging/arch/inferbound.rst:473
msgid "**Ex. 5**"
msgstr ""

#: ../../_staging/arch/inferbound.rst:475
msgid ""
"Compute_at is commonly applied after splitting, but this can be handled very"
" naturally given the above definitions. In the example below, the attachment"
" point of C is j_inner of D. The attach path of C is {j_inner, j_outer, i}."
msgstr ""

#: ../../_staging/arch/inferbound.rst:485
msgid "The IR in this case looks like:"
msgstr ""

#: ../../_staging/arch/inferbound.rst:496
msgid "Building an Attach Path"
msgstr ""

#: ../../_staging/arch/inferbound.rst:498
msgid ""
"We continue to refer to stages C and D, as introduced in the previous "
"section. The CreateAttachPath algorithm builds the attach path of a stage C "
"as follows. If C does not have attach_type ``kScope``, then C has no "
"attachment, and C's attach path is empty. Otherwise, C is attached at "
"attach_stage=D. We iterate through D's leaf variables in top-down order. All"
" leaf variables starting from C.attach_ivar and lower are added to C's "
"attach path. Then, if D is also attached somewhere, e.g., to stage E, the "
"process is repeated for E's leaves. Thus CreateAttachPath continues to add "
"variables to C's attach path until a stage with no attachment is "
"encountered."
msgstr ""

#: ../../_staging/arch/inferbound.rst:500
msgid "In the example below, C is attached at D, and D is attached at E."
msgstr ""

#: ../../_staging/arch/inferbound.rst:511
msgid ""
"With ``debug_keep_trivial_loop=True``, the attach path of C is {dj, di, ej, "
"ei}, and the attach path of D is {ej, ei}:"
msgstr ""

#: ../../_staging/arch/inferbound.rst:544
msgid ""
"Now that the concept of an attach path has been introduced, we return to how"
" InferBound differs if the schedule contains compute_at. The only difference"
" is in InferRootBound, :ref:`Phase1` and :ref:`Phase2`."
msgstr ""

#: ../../_staging/arch/inferbound.rst:546
msgid ""
"In InferRootBound, the goal is to determine Ranges for the root_iter_vars of"
" a particular stage, C. Phases 1-2 of InferRootBound assign IntSets to the "
"leaf IterVars of C's consumers, and then propagate those IntSets up to the "
"consumers' root_iter_vars."
msgstr ""

#: ../../_staging/arch/inferbound.rst:548
msgid ""
"If there are no attachments, the Ranges already computed for the consumer's "
"variables define how much of C is needed by the consumer. However, if the "
"stage is actually inside the scope of one of the consumer's variables j, "
"then only a single point within the Range of j is needed at a time."
msgstr ""

#: ../../_staging/arch/inferbound.rst:562
msgid ""
"In Phase 1, IntSets for each of the consumer's leaf_iter_vars are created, "
"based on the Ranges of the leaf_iter_vars from rmap. Recall that the "
"consumer has already been visited by InferBound, so all of its IterVars have"
" known Ranges in rmap."
msgstr ""

#: ../../_staging/arch/inferbound.rst:567
msgid ""
"Case 2: No relaxation is needed. In this case, the up_state for the leaf is "
"just a single point, defined by the leaf var itself."
msgstr ""

#: ../../_staging/arch/inferbound.rst:570
msgid ""
"Case 2 occurs if we encounter the attachment point of stage C in the "
"consumer. For this attach_ivar, and all higher leaf variables of the "
"consumer, Case 2 will be applied. This ensures that only a single point "
"within the Range of the leaf variable will be requested, if C is inside the "
"leaf variable's scope."
msgstr ""

#: ../../_staging/arch/inferbound.rst:587
msgid ""
"Case 2: Otherwise, the parent's ``up_state`` is defined by evaluating "
"``outer*f + inner + rmap[parent]->min``, with respect to the ``up_state`` of"
" outer and inner. Here, instead of using the Split relation's factor, TVM "
"uses* ``f = rmap[inner]->extent``."
msgstr ""

#: ../../_staging/arch/inferbound.rst:590
msgid ""
"Now, because the schedule contains compute_at, it is possible for Case 2 to "
"apply. This is because the leaf IntSets may now be initialized to a single "
"point within their Range (Case 2 of :ref:`Phase1CA`), so the IntSets will no"
" longer always match the Ranges."
msgstr ""

#: ../../_staging/arch/inferbound.rst:592
msgid ""
"After PassUpDomain has finished propagating up_state to all IterVars of the "
"consumer, a fresh map, from root_iter_vars to IntSet, is created. If the "
"stage is not attached to the current consumer, then for each variable iv in "
"the consumer's attach_path, iv's Range is added to a ``relax_set``. The root"
" variables of the stage are evaluated with respect to this ``relax_set``."
msgstr ""

#: ../../_staging/arch/inferbound.rst:594
msgid ""
"This is to handle cases like the following example, where C is not attached "
"anywhere, but its consumer D is attached in stage E. In this case, D's "
"attach_path, {ej, ei} must be considered when determining how much of C must"
" be computed."
msgstr ""

#: ../../_staging/arch/inferbound.rst:616
msgid "Limitations of PassUpDomain"
msgstr ""

#: ../../_staging/arch/inferbound.rst:618
msgid ""
"This section describes known limitations of PassUpDomain. These limitations "
"affect the Ranges produced by InferBound, as well as other users of "
"PassUpDomain such as ``tensorize``."
msgstr ""

#: ../../_staging/arch/inferbound.rst:620
msgid "**Ex. 6**"
msgstr ""

#: ../../_staging/arch/inferbound.rst:622
msgid ""
"Above, we discussed the behavior of PassUpDomain on Split relations only. In"
" the following example, the schedule contains ``fuse`` in addition to "
"``split``. In the TVM program below, the operation C has two axes that are "
"fused, and then the fused axis is split. Note that all tensors are "
"originally of shape ``(4, 4)`` and the fused axis is split by factor ``4`` "
"as well. Therefore, it would be natural to assume that the effect of the "
"fuse is simply undone by the split. However, this is not the case in TVM, as"
" explained below."
msgstr ""

#: ../../_staging/arch/inferbound.rst:645
msgid ""
"The output of this program is shown below. Notice that all 16 elements of B "
"are computed every time through the outer loop, even though C only uses 4 of"
" them."
msgstr ""

#: ../../_staging/arch/inferbound.rst:666
msgid ""
"This is in contrast to the following IR, which is produced by modifying the "
"above program by deleting the fuse and split, and replacing the compute_at "
"with ``s[B].compute_at(s[C], C.op.axis[0])``. Note that in the IR below, "
"only 4 elements of B are computed at a time, as desired. The size of buffer "
"B is also smaller."
msgstr ""

#: ../../_staging/arch/inferbound.rst:685
msgid ""
"This example demonstrates that contrary to what we expect, the split does "
"not simply undo the fuse. So what causes the difference? Why is the entire "
"tensor B re-computed 4 times, when only a single row is actually needed at a"
" time?"
msgstr ""

#: ../../_staging/arch/inferbound.rst:687
msgid ""
"Determining the amount of B that must be computed is the responsibility of "
"InferBound. However, the Ranges returned by InferBound for B's "
"root_iter_vars are too large in this case: ``[0, 4]`` for both ``bi`` and "
"``bj``.  This occurs because of a limitation in PassUpDomain on Fuse "
"relations, which we explain next."
msgstr ""

#: ../../_staging/arch/inferbound.rst:689
msgid ""
"When InferRootBound is working on stage B, it visits B's consumer stage C to"
" find out how much of B is requested by C. C has root_iter_vars ci and cj, "
"which have been fused and then split. This results in the following "
":ref:`IterVarHyperGraph` for stage C."
msgstr ""

#: ../../_staging/arch/inferbound.rst:697
msgid ""
"We trace the execution of InferRootBound on stage B. Recall that "
":ref:`Phase1CA` of InferRootBound involves setting the IntSets for all "
"leaf_iter_vars of B's consumer stage C. In this case, C's leaf_iter_vars are"
" ``ci.cj.fused.outer`` and ``ci.cj.fused.inner``.  Since B is attached at "
"``ci.cj.fused.outer``, ``ci.cj.fused.inner`` must be relaxed but "
"``ci.cj.fused.outer`` is a single point. The IntSets of C's leaf_iter_vars, "
"after :ref:`Phase1CA`, are shown in the following table."
msgstr ""

#: ../../_staging/arch/inferbound.rst:700
#: ../../_staging/arch/inferbound.rst:712
#: ../../_staging/arch/inferbound.rst:732
msgid "IterVar"
msgstr ""

#: ../../_staging/arch/inferbound.rst:700
msgid "IntSet after Phase 1"
msgstr ""

#: ../../_staging/arch/inferbound.rst:702
#: ../../_staging/arch/inferbound.rst:714
#: ../../_staging/arch/inferbound.rst:734
msgid "``ci.cj.fused.inner``"
msgstr ""

#: ../../_staging/arch/inferbound.rst:702
#: ../../_staging/arch/inferbound.rst:714
#: ../../_staging/arch/inferbound.rst:734
msgid "``[0, (min(4, (16 - (ci.cj.fused.outer*4))) - 1)]``"
msgstr ""

#: ../../_staging/arch/inferbound.rst:704
#: ../../_staging/arch/inferbound.rst:716
#: ../../_staging/arch/inferbound.rst:736
msgid "``ci.cj.fused.outer``"
msgstr ""

#: ../../_staging/arch/inferbound.rst:704
#: ../../_staging/arch/inferbound.rst:716
#: ../../_staging/arch/inferbound.rst:736
msgid "``[ci.cj.fused.outer, ci.cj.fused.outer]``"
msgstr ""

#: ../../_staging/arch/inferbound.rst:707
msgid ""
"In :ref:`Phase2CA` of InferRootBound, PassUpDomain is called on all of C's "
"IterVarRelations in bottom-up order."
msgstr ""

#: ../../_staging/arch/inferbound.rst:709
msgid ""
"PassUpDomain is called on C's Split node first. Case 2 of PassUpDomain "
"applies, because the IntSet of ``ci.cj.fused.outer`` is just a single point,"
" and doesn't equal its Range (as previously computed by InferBound on stage "
"C). PassUpDomain therefore sets the IntSet of ``ci.cj.fused`` based on the "
"IntSets of ``ci.cj.fused.inner`` and ``ci.cj.fused.outer``, as shown in row "
"3 of the following table."
msgstr ""

#: ../../_staging/arch/inferbound.rst:712
msgid "IntSet after PassUpDomain on SplitNode"
msgstr ""

#: ../../_staging/arch/inferbound.rst:718
#: ../../_staging/arch/inferbound.rst:738
msgid "``ci.cj.fused``"
msgstr ""

#: ../../_staging/arch/inferbound.rst:718
#: ../../_staging/arch/inferbound.rst:738
msgid ""
"``[(ci.cj.fused.outer*4), ((ci.cj.fused.outer*4) + (min(4, (16 - "
"(ci.cj.fused.outer*4))) - 1))]``"
msgstr ""

#: ../../_staging/arch/inferbound.rst:721
msgid ""
"After PassUpDomain is called on the Split node, it is called on the Fuse "
"node."
msgstr ""

#: ../../_staging/arch/inferbound.rst:723
msgid ""
"Case 1: the Range of IterVar ``fused`` (i.e., as previously calculated by "
"InferBound) is equal to its IntSet"
msgstr ""

#: ../../_staging/arch/inferbound.rst:724
msgid "Case 2: the IntSet of IterVar ``fused`` is a single point"
msgstr ""

#: ../../_staging/arch/inferbound.rst:725
msgid "Case 3: otherwise"
msgstr ""

#: ../../_staging/arch/inferbound.rst:727
msgid ""
"In our case, the Range of ``ci.cj.fused``, is [0, 16). This is not equal to "
"the IntSet of ``ci.cj.fused``, which has extent at most 4 (see row 3 of the "
"table above). Therefore Case 1 does not apply.  Case 2 doesn't apply either,"
" since the IntSet of ``ci.cj.fused`` is not a single point.  Therefore, only"
" the default Case 3 applies."
msgstr ""

#: ../../_staging/arch/inferbound.rst:729
msgid ""
"Unfortunately in Case 3, PassUpDomain conservatively applies a \"fallback "
"inference rule\", i.e., it just returns IntSets equal to the Ranges of "
"``ci`` and ``cj``. Since C is the output stage of the schedule, we know that"
" InferBound will have set the Ranges of the root_iter_vars of C (i.e., "
"``ci`` and ``cj``) to their original dimensions (i.e., the ``dom`` value of "
"their IterVars). The resulting output of PassUpDomain for ``ci`` and ``cj`` "
"is shown in the last two rows of the table below."
msgstr ""

#: ../../_staging/arch/inferbound.rst:732
msgid "IntSet after PassUpDomain on FuseNode"
msgstr ""

#: ../../_staging/arch/inferbound.rst:740
msgid "``ci``"
msgstr ""

#: ../../_staging/arch/inferbound.rst:740
#: ../../_staging/arch/inferbound.rst:742
msgid "``[0, 4]``"
msgstr ""

#: ../../_staging/arch/inferbound.rst:742
msgid "``cj``"
msgstr ""

#: ../../_staging/arch/inferbound.rst:745
msgid ""
"This is enough to guarantee that consumer C requests *all* elements of B: "
"the IntSets of ``ci`` and ``cj`` become requests from consumer C to the "
"output tensors of stage B (via PropBoundToInputs in :ref:`Phase3` and "
"GatherBound in :ref:`Phase4`)."
msgstr ""

#: ../../_staging/arch/inferbound.rst:747
msgid ""
"This example shows that schedules containing a split of fused axes are "
"difficult to handle in TVM. The source of the difficulty is similar to the "
"limitations of GatherBound. The region of tensor B requested by a consumer C"
" must be a single rectangular region of B. Or, if B has more than two "
"dimensions, the region of B must be expressible as an independent Range for "
"each of its axes."
msgstr ""

#: ../../_staging/arch/inferbound.rst:749
msgid ""
"If the split factor is 4, or 8, in the above example, the region of B needed"
" in each iteration of the outer loop is rectangular."
msgstr ""

#: ../../_staging/arch/inferbound.rst:754
msgid ""
"However, if the split factor is changed from 4 to 3 in the example above, it"
" is easy to see that the region of B that C needs can no longer be described"
" by an independent Range for each of its axes."
msgstr ""

#: ../../_staging/arch/inferbound.rst:760
msgid ""
"The best that can be done with rectangular regions is shown in the following"
" diagram. The orange regions are the minimum rectangular regions covering "
"the region of B that needs to be computed, at each iteration of the outer "
"loop."
msgstr ""
