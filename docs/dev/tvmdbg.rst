=================
**Debugger**
=================

TVM Debugger is an interface for debugging TVM's computation graph execution. It helps to provide access to graph structures and tensor values at the TVM runtime.

*******************************************
**Debug Exchange Format**
*******************************************

**1. Computational Graph**
==========================
The optimized graph build by nnvm in json
serialized format is dumped as it is. This contains the whole
information about the graph. The UX can either use this graph directly
or transform this graph to the format UX can understand.

The Graph JSON format is explained below

1. ``nodes``
Nodes are either placeholders or computational nodes in NNVM graph. The nodes are stored
as a list. A node contains the below information

-     ``op`` - operation type, ``null`` means it is a placeholder/variable/input node and``tvm_op`` means this node can be executed
-     ``name`` - Name of the node
-     ``inputs`` - Position of the inputs for this operation, Inputs is a list of tuples with (nodeid, index, version). (Optional)
-     ``attrs`` - Attributes of the node which contains the following information

    -     ``flatten_data`` - Whether this data need to be flattened before execution
    -     ``func_name`` - Fused function name, corresponds to the symbol in the lib generated by NNVM compilation process.
    -     ``num_inputs`` - Number of inputs for this node
    -     ``num_outputs`` - Number of outputs this node produces

2. ``arg_nodes``
arg_nodes is a list of indices of nodes which is placeholder/variable/input or constant/param to the graph.

3. ``heads``
heads is a list of entries as the output of the graph.

4. ``node_row_ptr``
node\_row\_ptr stores the history of forward path, so you can skip constructing the entire graph in inference tasks.

5. ``attrs``
attrs can contain version numbers or similar helpful information.

- ``storage_id`` - memory slot id for each node in the storage layout
- ``dtype`` - Datatype of each node (enum value)
- ``dltype`` - Datatype of each node in order
- ``shape`` - Shape of each node k order

Example of dumped graph:

::

    {
      "nodes": [                                    # List of nodes
        {
          "op": "null",                             # operation type = null, this is a placeholder/variable/input or constant/param node
          "name": "x",                              # Name of the argument node
          "inputs": []                              # inputs for this node, its none since this is an argument node
        },
        {
          "op": "tvm_op",                           # operation type = tvm_op, this node can be executed
          "name": "relu0",                          # Name of the node
          "attrs": {                                # Attributes of the node
            "flatten_data": "0",                    # Whether this data need to be flattened
            "func_name": "fuse_l2_normalize_relu",  # Fused function name, corresponds to the symbol in the lib generated by NNVM compilation process
            "num_inputs": "1",                      # Number of inputs for this node
            "num_outputs": "1"                      # Number of outputs this node produces
          },
          "inputs": [[0, 0, 0]]                     # Position of the inputs for this operation
        }
      ],
      "arg_nodes": [0],                             # Which all nodes in this are argument nodes
      "node_row_ptr": [0, 1, 2],                    # Row indices for faster depth first search
      "heads": [[1, 0, 0]],                         # Position of the output nodes for this operation
      "attrs": {                                    # Attributes for the graph
        "storage_id": ["list_int", [1, 0]],         # memory slot id for each node in the storage layout
        "dtype": ["list_int", [0, 0]],              # Datatype of each node (enum value)
        "dltype": ["list_str", [                    # Datatype of each node in order
            "float32",
            "float32"]],
        "shape": ["list_shape", [                   # Shape of each node k order
            [1, 3, 20, 20],
            [1, 3, 20, 20]]]
      }
    }

**2. Tensor dumping**
=====================

The tensor received after execution is in ``tvm.ndarray`` type. All the tensors will
be saved as binary bytes in serialized format.  The result binary bytes can be loaded by the
API "load_params".

Example of loading the parameters
   ::
    with open(path_params, "rb") as fi:
        loaded_params = bytearray(fi.read())

    module.load_params(loaded_params)

***************************************
How to use Debugger?
***************************************

1. In ``config.cmake`` set the ``USE_GRAPH_RUNTIME_DEBUG`` flag to ``ON``

   ::

       # Whether enable additional graph debug functions
       set(USE_GRAPH_RUNTIME_DEBUG ON)

2. Do 'make' tvm, so that it will make the ``libtvm_runtime.so``

3. In frontend script file instead of
   ``from tvm.contrib import graph_runtime`` import the
   ``debug_runtime``
   ``from tvm.contrib.debugger import debug_runtime as graph_runtime``

::

    from tvm.contrib.debugger import debug_runtime as graph_runtime
    m = graph_runtime.create(graph, lib, ctx, dump_root="/tmp/tvmdbg")
    # set inputs
    m.set_input('data', tvm.nd.array(data.astype(dtype)))
    m.set_input(**params)
    # execute
    m.run()
    tvm_out = m.get_output(0, tvm.nd.empty(out_shape, dtype)).asnumpy()

The outputs are dumped to a temporary folder in ``/tmp`` folder or the
folder specified while creating the runtime.

***************************************
Sample Output
***************************************

The below is the output of running  ``tvm/nnvm/tutorials/from_onnnx.py`` with debugger.

::

    Node Name        Ops                                Time(us)             Shape               Inputs       Outputs
    ---------        ---                                --------             -----               ------       -------
    relu0            fuse_conv2d_broadcast_add_relu     14840.649            (1, 1, 224, 224)    3            1
    relu1            fuse_conv2d_broadcast_add_relu_1   224299.577           (64, 1, 5, 5)       3            1
    relu2            fuse_conv2d_broadcast_add_relu_2   111466.68699999999   (64, 1, 1)          3            1
    broadcast_add3   fuse_conv2d_broadcast_add          25375.287            (1, 64, 224, 224)   3            1
    reshape1         fuse_reshape_transpose_reshape     1309.9260000000002   (64, 64, 3, 3)      1            1