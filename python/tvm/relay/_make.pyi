# from typing import Dict, List, Any, Callable, TypeVar as PyTypeVar
# import nnvm.relay.ir as ir
# import nnvm.relay.env as env
# import ctypes

# # Environment
# def Environment(items: Dict[ir.GlobalId, ir.Item]) -> env.Environment: ...

# # Items TODO(@jroesch) Correct Anys to the right type.
# def Operator(id: ir.OperatorId, tvm_name: str, ty: ir.Type, compiler: Any, fwd_mode: Any, rev_mode: Any) -> ir.Operator: ...
# def Defn(id: ir.GlobalId, ty: ir.Type, body: ir.Function) -> ir.Defn: ...

# # Types
# def IntType(bits: int, lanes: int) -> ir.Type: ...
# def UIntType(bits: int, lanes: int) -> ir.Type: ...
# def FloatType(bits: int, lanes: int) -> ir.Type: ...
# def BoolType(lanes: int) -> ir.Type: ...
# def TupleType(fields: List[ir.Type]) -> ir.Type: ...
# def TensorType(dtype: ir.Type, shape: ir.Type) -> ir.Type: ...
# def TypeParam(name: str, kind: ir.Kind) -> ir.Type: ...
# def TypeQuantifier(id: ir.TypeId, body: ir.Type) -> ir.Type: ...
# def TypeArrow(left: ir.Type, right: ir.Type) -> ir.Type: ...
# def TypeVar(kind: ir.Kind) -> ir.Type: ...
# def PlaceholderType() -> ir.Type: ...
# def ShapeSeq(shapes: List[ir.Type]) -> ir.ShapeSeq: ...
# def ShapeSingleton(value: int) -> ir.ShapeSingleton: ...
# def ShapeAttr(id: ir.StringLit) -> ir.ShapeAttr: ...
# def ShapeProjection(shape: ir.Type, value: int) -> ir.ShapeProjection: ...
# def ShapeBinaryOp(op: ir.ShapeOp, left: ir.Type, right: ir.Type) -> ir.ShapeBinaryOp: ...
# def ShapeBroadcast(left: ir.Type, right: ir.Type) -> ir.ShapeBroadcast: ...
# def ShapeExtension(name: str, eval: Any) -> ir.ShapeExtension: ...
# def TypeCall(func: ir.Type, args: List[ir.Type]) -> ir.TypeCall: ...
# def RefType(data_type: ir.Type) -> ir.RefType: ...

# # Expressions
# def Param(id: ir.LocalId, type: ir.Type) -> ir.Param: ...
# def Function(ty_params: List[ir.TypeId], params: List[ir.Param], ret_type: ir.Type, body: ir.Expr) -> ir.Function: ...
# def LocalId(name: str) -> ir.Expr: ...
# def GlobalId(name: str) -> ir.Expr: ...
# def OperatorId(name: str) -> ir.Expr: ...
# def Let(id: ir.LocalId, ty: ir.Type, value: ir.Expr, body: ir.Expr) -> ir.Expr: ...
# def IntLit(value: int) -> ir.IntLit: ...
# def FloatLit(value: float) -> ir.FloatLit: ...
# def TensorLit(value: List[ir.Expr]) -> ir.TensorLit: ...
# def Tuple(fields: List[ir.Expr]) -> ir.Expr: ...
# def BoolLit(value: bool) -> ir.BoolLit: ...
# def StringLit(value: str) -> ir.StringLit: ...
# def Attributes(attrs: Dict[str, ir.Expr]) -> ir.Attributes: ...
# def Call(func: ir.Expr, args: List[ir.Expr], attrs: ir.Attributes) -> ir.Call: ...
# def UnaryOp(op: ir.UOp, arg: ir.Expr) -> ir.Expr: ...
# def BinaryOp(op: ir.BOp, left: ir.Expr, right: ir.Expr) -> ir.Expr: ...
# def Projection(tuple: ir.Expr, field : int) -> ir.Expr: ...
# def Gradient(node: ir.Expr) -> ir.Expr: ...
# def Cast(target: ir.Type, node: ir.Expr) -> ir.Expr: ...
# def Debug(node: ir.Expr) -> ir.Expr: ...
# def Zero(type: ir.Type) -> ir.Expr: ...
# def If(guard: ir.Expr, true_branch: ir.Expr, false_branch: ir.Expr) -> ir.Expr: ...
# def Ref(value: ir.Expr) -> ir.Expr: ...
# def ReadRef(ref: ir.Expr) -> ir.Expr: ...
# def WriteRef(ref: ir.Expr, value: ir.Expr) -> ir.Expr: ...

# # Values
# def IntValue(value: int) -> ir.TensorValue: ...
# def FloatValue(value: float) -> ir.TensorValue: ...
# def BoolValue(value: bool) -> ir.TensorValue: ...
# def TensorValue(handle: ctypes.c_void_p) -> ir.TensorValue: ...
# def Closure(env: Dict[ir.LocalId, ir.Value], fn: ir.Function) -> ir.Closure: ...

# # Error Reporting
# def Span(file_id: ir.FileId, lineno: int, col_offset: int) -> ir.NodeBase: ...
# def FileId(file_id: int) -> ir.FileId: ...

# # Utils
# def _alpha_eq(e1: ir.Expr, e2: ir.Expr) -> bool: ...
# def _type_alpha_eq(e1: ir.Type, e2: ir.Type) -> bool: ...
# def _expr_set_span(e: ir.Expr, sp: ir.Span) -> None: ...
# def _type_set_span(t: ir.Type, sp: ir.Span) -> None: ...
# def _item_set_span(t: ir.Item, sp: ir.Span) -> None: ...
# def Node_hash(n: ir.Node) -> int: ...
# def Operator_is_generic(op: ir.Operator) -> bool: ...

# # FIXME
# def UnionFind() -> Any: ...
# def TypeUnifier() -> Any: ...

# T = PyTypeVar('T')
# U = PyTypeVar('U')
# PassFunc = Callable[[env.Environment], Callable[[T], U]]

# # Passes
# def ItemPass(name: str, pass_func: PassFunc[ir.Item, ir.Item]) -> ir.ItemPass: ...
