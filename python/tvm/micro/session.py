# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.

"""Defines a top-level glue class that operates the Transport and Flasher classes."""

import io
import json
import logging
import os
import tarfile
import tempfile
import sys

from ..error import register_error
from .._ffi import get_global_func, register_func
from ..contrib import graph_exectuor
from ..contrib.debugger import debug_executor
from ..rpc import RPCSession
from .transport import IoTimeoutError
from .transport import TransportLogger
from . import build
from . import compiler

try:
    from .base import _rpc_connect
except ImportError:
    raise ImportError("micro tvm is not enabled. Set USE_MICRO to ON in config.cmake")


@register_error
class SessionTerminatedError(Exception):
    """Raised when a transport read operationd discovers that the remote session is terminated."""


class Session:
    """MicroTVM Device Session

    Parameters
    ----------
    config : dict
        configuration for this session (as generated by
        `tvm.micro.device.host.default_config()`, for example)

    Example
    --------
    .. code-block:: python

      c_mod = ...  # some module generated with "c" as the target
      dev_config = micro.device.arm.stm32f746xx.default_config('127.0.0.1', 6666)
      with tvm.micro.Session(dev_config) as sess:
          micro_mod = sess.create_micro_mod(c_mod)
    """

    def __init__(
        self,
        transport_context_manager=None,
        session_name="micro-rpc",
        timeout_override=None,
    ):
        """Configure a new session.

        Parameters
        ----------
        transport_context_manager : ContextManager[transport.Transport]
            If given, `flasher` and `binary` should not be given. On entry, this context manager
            should establish a tarnsport between this TVM instance and the device.
        session_name : str
            Name of the session, used for debugging.
        timeout_override : TransportTimeouts
            If given, TransportTimeouts that govern the way Receive() behaves. If not given, this is
            determined by calling has_flow_control() on the transport.
        """
        self.transport_context_manager = transport_context_manager
        self.session_name = session_name
        self.timeout_override = timeout_override

        self._rpc = None
        self._graph_executor = None

    def get_system_lib(self):
        return self._rpc.get_function("runtime.SystemLib")()

    def _wrap_transport_read(self, n, timeout_microsec):
        try:
            return self.transport.read(
                n, float(timeout_microsec) / 1e6 if timeout_microsec is not None else None
            )
        except IoTimeoutError:
            return bytes([])

    def _wrap_transport_write(self, data, timeout_microsec):
        self.transport.write(
            data, float(timeout_microsec) / 1e6 if timeout_microsec is not None else None
        )

        return len(data)  # TODO(areusch): delete

    def __enter__(self):
        """Initialize this session and establish an RPC session with the on-device RPC server.

        Returns
        -------
        Session :
            Returns self.
        """
        self.transport = TransportLogger(
            self.session_name, self.transport_context_manager, level=logging.DEBUG
        ).__enter__()

        try:
            timeouts = self.timeout_override
            if timeouts is None:
                timeouts = self.transport.timeouts()

            self._rpc = RPCSession(
                _rpc_connect(
                    self.session_name,
                    self._wrap_transport_write,
                    self._wrap_transport_read,
                    int(timeouts.session_start_retry_timeout_sec * 1e6),
                    int(timeouts.session_start_timeout_sec * 1e6),
                    int(timeouts.session_established_timeout_sec * 1e6),
                )
            )
            self.device = self._rpc.cpu(0)
            return self

        except:
            self.transport.__exit__(*sys.exc_info())
            raise

    def __exit__(self, exc_type, exc_value, exc_traceback):
        """Tear down this session and associated RPC session resources."""
        self.transport.__exit__(exc_type, exc_value, exc_traceback)


def lookup_remote_linked_param(mod, storage_id, template_tensor, device):
    """Lookup a parameter that has been pre-linked into a remote (i.e. over RPC) Module.

    This function signature matches the signature built by

    Parameters
    ----------
    mod : tvm.runtime.Module
        The remote Module containing the pre-linked parameters.
    storage_id : int
        An integer identifying the pre-linked paramter to find
    template_tensor : DLTensor
        A DLTensor containing metadata that should be filled-in to the returned NDArray. This
        function should mostly not inspect this, and just pass it along to
        NDArrayFromRemoteOpaqueHandle.
    device : Device
        The remote CPU device to be used with the returned NDArray.

    Returns
    -------
    tvm.nd.NDArray :
        NDArray containing the pre-linked parameter.
    """
    try:
        lookup_linked_param = mod.get_function("_lookup_linked_param")
    except AttributeError:
        return None

    remote_data = lookup_linked_param(storage_id)
    if remote_data is None:
        return None

    return get_global_func("tvm.rpc.NDArrayFromRemoteOpaqueHandle")(
        mod, remote_data, template_tensor, device, None
    )


def create_local_graph_executor(graph_json_str, mod, device):
    """Create a local graph executor driving execution on the remote CPU device given.

    Parameters
    ----------
    graph_json_str : str
        A string containing the graph representation.

    mod : tvm.runtime.Module
        The remote module containing functions in graph_json_str.

    device : tvm.runtime.Device
        The remote CPU execution device.

    Returns
    -------
    tvm.contrib.GraphExecutor :
         A local graph executor instance that executes on the remote device.
    """
    device_type_id = [device.device_type, device.device_id]
    fcreate = get_global_func("tvm.graph_executor.create")
    return graph_executor.GraphModule(
        fcreate(graph_json_str, mod, lookup_remote_linked_param, *device_type_id)
    )


def create_local_debug_executor(graph_json_str, mod, device, dump_root=None):
    """Create a local debug runtime driving execution on the remote CPU device given.

    Parameters
    ----------
    graph_json_str : str
        A string containing the graph representation.

    mod : tvm.runtime.Module
        The remote module containing functions in graph_json_str.

    device : tvm.runtime.Device
        The remote CPU execution device.

    dump_root : Optional[str]
        If given, passed as dump_root= to GraphModuleDebug.

    Returns
    -------
    tvm.contrib.GraphExecutor :
         A local graph executor instance that executes on the remote device.
    """
    device_type_id = [device.device_type, device.device_id]
    fcreate = get_global_func("tvm.graph_executor_debug.create")
    return debug_executor.GraphModuleDebug(
        fcreate(graph_json_str, mod, lookup_remote_linked_param, *device_type_id),
        [device],
        graph_json_str,
        dump_root=dump_root,
    )


RPC_SESSION = None


@register_func("tvm.micro.create_micro_session")
def create_micro_session(
    build_result_filename: str, build_result_bin: bytes, flasher_factory_json: bytes
):
    """Unarchive the provided MicroBinary, flash it to device, and open a microTVM RPC session.

    This function is meant to be called as a TVM RPC Session Constructor (i.e. by passing it to
    `session_constructor_args` of tvm.rpc.connect(). It returns an RPCSession node that can be used
    for further communication with the device.

    Parameters
    ----------
    build_result_filename : str
        Baseame of the MicroBinary file to create.

    build_result_bin : bytes
        The content of the MicroBinary artifact produced by the compiler.

    flasher_factory_json : bytes
        JSON that can be used to create a FlasherFactory with FactoryFlasher.from_json.

    Returns
    -------
    tvm.runtime.Module :
        The underlying RPCSession node which can be used by the RPC subsystem to forward requests
        to the attached target.
    """
    global RPC_SESSION
    if RPC_SESSION is not None:
        raise Exception(
            "Only one micro session can be established per TVM instance, and one is already "
            "established"
        )

    with tempfile.NamedTemporaryFile(prefix=build_result_filename, mode="w+b") as temp_f:
        temp_f.write(build_result_bin)
        temp_f.flush()

        binary = micro_binary.MicroBinary.unarchive(
            temp_f.name, os.path.join(tempfile.mkdtemp(), "binary")
        )
        flasher_obj = compiler.FlasherFactory.from_json(flasher_factory_json).instantiate()

        RPC_SESSION = Session(binary=binary, flasher=flasher_obj)
        RPC_SESSION.__enter__()
        return RPC_SESSION._rpc._sess


@register_func("tvm.micro.compile_and_create_micro_session")
def compile_and_create_micro_session(
    compiler_factory_json: bytes,
    mod_src_tar: bytes,
    compiler_options_json: str,
    lib_paths_json: str,
    workspace_kw_json: str,
):
    """Compile the given libraries and sources into a MicroBinary, then invoke create_micro_session.

    Parameters
    ----------
    compiler_factory_json : bytes
        JSON that can be used to create a CompilerFactory with CompilerFactory.from_json.

    mod_src_tar : bytes
        The content of a tarfile which contains the TVM-generated sources which together form the
        SystemLib. This tar is expected to be created by export_library. The tar will be extracted
        into a directory and the sources compiled into a MicroLibrary using the Compiler.

    compiler_options_json : str
        JSON representation of the compiler options (i.e. returned from
        tvm.micro.get_default_options()) which are passed to library() and binary() calls.

    lib_paths_json : str
        JSON-encoded list of paths to files, each produced by MicroLibrary.archive(). Each
        MicroLibrary will be unarchived and added to the list of libs included in the MicroBinary.
        NOTE: in the future, the sources to these libraries should be supplied and compilation will
        occur in this function.

    workspace_kw_json : str
        JSON-encoded keyword args to the Workspace constructor, used for temporary storage for this
        compilation.
    """
    global RPC_SESSION

    lib_paths = json.loads(lib_paths_json)
    workspace = build.Workspace(**json.loads(workspace_kw_json))
    compiler_inst = compiler.CompilerFactory.from_json(compiler_factory_json).instantiate()
    compiler_options = json.loads(compiler_options_json)

    mod_src_dir = workspace.relpath(os.path.join("src", "module"))
    os.makedirs(mod_src_dir)
    tar_f = tarfile.open(fileobj=io.BytesIO(mod_src_tar), mode="r:*")
    tar_f.extractall(mod_src_dir)

    mod_build_dir = workspace.relpath(os.path.join("lib", "module"))
    os.makedirs(mod_build_dir)
    mod_src_paths = [os.path.join(mod_src_dir, n) for n in tar_f.getnames()]
    mod_lib = compiler_inst.library(
        mod_build_dir, mod_src_paths, compiler_options["generated_lib_opts"]
    )

    libs = []
    for lib_path in lib_paths:
        # Split off the .micro-library extension
        lib_dir_name = os.path.splitext(os.path.basename(lib_path))[0]
        lib_dir = workspace.relpath(os.path.join("lib", lib_dir_name))

        libs.append(micro_library.MicroLibrary.unarchive(lib_path, lib_dir))

    libs.append(mod_lib)

    runtime_build_dir = workspace.relpath(os.path.join("runtime"))
    os.makedirs(runtime_build_dir)
    print("build binary", runtime_build_dir)
    binary = compiler_inst.binary(runtime_build_dir, libs, compiler_options["bin_opts"])

    RPC_SESSION = Session(binary=binary, flasher=compiler_inst.flasher())
    RPC_SESSION.__enter__()
    return RPC_SESSION._rpc._sess


@register_func
def destroy_micro_session():
    global RPC_SESSION
    if RPC_SESSION is not None:
        exc_type, exc_value, traceback = RPC_SESSION.__exit__(None, None, None)
        RPC_SESSION = None
        if (exc_type, exc_value, traceback) != (None, None, None):
            exc = exc_type(exc_value)  # See PEP 3109
            exc.__traceback__ = traceback
            raise exc
