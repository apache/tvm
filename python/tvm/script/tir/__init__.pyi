from typing import (
    Any,
    Callable,
    ContextManager,
    Dict,
    Iterable,
    Object,
    Optional,
    Tuple,
    Union,
    Sequence,
    List,
    Mapping,
)
from tvm.ir import Span
from tvm.tir.function import PrimFunc
from tvm.tir import PrimExpr, Buffer, IterVar, Var, Ptr
from .node import BufferSlice

"""
Variables and constants
"""

def bool(imm: int, span: Span) -> PrimExpr: ...
def int8(imm: int, span: Span) -> PrimExpr: ...
def int16(imm: int, span: Span) -> PrimExpr: ...
def int32(imm: int, span: Span) -> PrimExpr: ...
def int64(imm: int, span: Span) -> PrimExpr: ...
def uint8(imm: int, span: Span) -> PrimExpr: ...
def uint16(imm: int, span: Span) -> PrimExpr: ...
def uint32(imm: int, span: Span) -> PrimExpr: ...
def uint64(imm: int, span: Span) -> PrimExpr: ...
def float8(imm: int, span: Span) -> PrimExpr: ...
def float16(imm: int, span: Span) -> PrimExpr: ...
def float32(imm: int, span: Span) -> PrimExpr: ...
def float64(imm: int, span: Span) -> PrimExpr: ...

"""
Intrinsic
"""

def min_value(dtype, span: Span): ...
def max_value(dtype, span: Span): ...
def floordiv(x: PrimExpr, y: PrimExpr, span: Span): ...
def floormod(x: PrimExpr, y: PrimExpr, span: Span): ...
def abs(x, span: Span): ...
def load(dtype, var, index, predicate=None, span: Span = None): ...
def cast(value, dtype, span: Span): ...
def ramp(base, stride, lanes, span: Span): ...
def broadcast(value, lanes, span: Span): ...
def iter_var(var, dom, iter_type, thread_tag, span: Span): ...
def max(a, b, span: Span): ...
def min(a, b, span: Span): ...
def get_axis(begin, end, iter_type, span: Span): ...
def range(begin, end, span: Span): ...
def reduce_axis(begin, end, span: Span): ...
def scan_axis(begin, end, span: Span): ...
def opaque_axis(begin, end, span: Span): ...
def Select(cond, if_body, else_body, span: Span): ...
def evaluate(value, span: Span): ...
def store(var, index, value, predicate=True, span: Span = None): ...
def comm_reducer(lambda_io, identities, span: Span): ...

"""
Unary operator
"""

def exp2(x: PrimExpr) -> PrimExpr: ...
def exp10(x: PrimExpr) -> PrimExpr: ...
def erf(x: PrimExpr) -> PrimExpr: ...
def tanh(x: PrimExpr) -> PrimExpr: ...
def sigmoid(x: PrimExpr) -> PrimExpr: ...
def log(x: PrimExpr) -> PrimExpr: ...
def log2(x: PrimExpr) -> PrimExpr: ...
def log10(x: PrimExpr) -> PrimExpr: ...
def log1p(x: PrimExpr) -> PrimExpr: ...
def tan(x: PrimExpr) -> PrimExpr: ...
def cos(x: PrimExpr) -> PrimExpr: ...
def cosh(x: PrimExpr) -> PrimExpr: ...
def acos(x: PrimExpr) -> PrimExpr: ...
def acosh(x: PrimExpr) -> PrimExpr: ...
def sin(x: PrimExpr) -> PrimExpr: ...
def sinh(x: PrimExpr) -> PrimExpr: ...
def asin(x: PrimExpr) -> PrimExpr: ...
def asinh(x: PrimExpr) -> PrimExpr: ...
def atan(x: PrimExpr) -> PrimExpr: ...
def atanh(x: PrimExpr) -> PrimExpr: ...
def atan2(x: PrimExpr) -> PrimExpr: ...
def sqrt(x: PrimExpr) -> PrimExpr: ...
def rsqrt(x: PrimExpr) -> PrimExpr: ...

"""
Loops
"""

def serial(begin: Union[PrimExpr, int], end: Union[PrimExpr, int]) -> Iterable[IterVar]: ...
def parallel(begin: Union[PrimExpr, int], end: Union[PrimExpr, int]) -> Iterable[IterVar]: ...
def vectorize(begin: Union[PrimExpr, int], end: Union[PrimExpr, int]) -> Iterable[IterVar]: ...
def unroll(begin: Union[PrimExpr, int], end: Union[PrimExpr, int]) -> Iterable[IterVar]: ...
def grid(*extents: Union[PrimExpr, int]) -> Iterable[Tuple[IterVar]]: ...
def range(begin: Union[PrimExpr, int], end: Union[PrimExpr, int]) -> Iterable[IterVar]: ...
def thread_binding(
    begin: Union[PrimExpr, int], end: Union[PrimExpr, int], thread: str
) -> Iterable[IterVar]: ...

"""
Axis
"""

def reduce_axis(begin: Union[PrimExpr, int], end: Union[PrimExpr, int]) -> IterVar: ...
def range(begin: Union[PrimExpr, int], end: Union[PrimExpr, int]) -> IterVar: ...
def scan_axis(begin: Union[PrimExpr, int], end: Union[PrimExpr, int]) -> IterVar: ...
def opaque_axis(begin: Union[PrimExpr, int], end: Union[PrimExpr, int]) -> IterVar: ...

"""
Buffers
"""

def match_buffer(
    param: Union[Var, BufferSlice],
    shape: Sequence[Union[PrimExpr, int]],
    dtype: str = "float32",
    data=None,
    strides: Optional[Sequence[int]] = None,
    elem_offset: Optional[int] = None,
    scope: str = "global",
    align: int = -1,
    offset_factor: int = 0,
    buffer_type: str = "default",
    span: Span = None,
) -> Buffer: ...
def buffer_decl(
    shape: Sequence[Union[PrimExpr, int]],
    dtype: str = "float32",
    data=None,
    strides: Optional[Sequence[int]] = None,
    elem_offset: Optional[int] = None,
    scope: str = "global",
    align: int = -1,
    offset_factor: int = 0,
    buffer_type: str = "default",
    span: Span = None,
) -> Buffer: ...
def alloc_buffer(
    shape: Sequence[Union[PrimExpr, int]],
    dtype: str = "float32",
    data=None,
    strides: Optional[Sequence[int]] = None,
    elem_offset: Optional[int] = None,
    scope: str = "global",
    align: int = -1,
    offset_factor: int = 0,
    buffer_type: str = "default",
    span: Span = None,
) -> Buffer: ...

"""
Reads/Writes
"""

def reads(read_regions: Union[BufferSlice, List[BufferSlice]], span: Span = None) -> None: ...
def writes(write_region: Union[BufferSlice, List[BufferSlice]], span: Span = None) -> None: ...
def block_attr(attrs: Mapping[str, Object], span: Span = None) -> None: ...

"""
Scope handler
"""

class block(ContextManager):
    def __init__(self, axes: Sequence[Union[int, PrimExpr, slice]], name: str = "") -> None: ...
    def __enter__(self) -> Sequence[IterVar]: ...

class init(ContextManager):
    def __init__(self) -> None: ...

class let(ContextManager):
    def __init__(self, var: Var, value: PrimExpr) -> None: ...

def where(cond: PrimExpr) -> None: ...
def realize(x: Buffer, scope: str, condition: bool = True) -> None: ...

"""
Threads and Bindings
"""

def env_thread(thread: str) -> IterVar: ...
def bind(iter_var: IterVar, expr: PrimExpr) -> None: ...

"""
Annotations
"""

def func_attr(attrs: Dict) -> None: ...
def block_attr(attrs: Dict) -> None: ...
def attr(node: PrimExpr, attr_key: str, value: PrimExpr) -> None: ...
def prim_func(input_func: Callable) -> PrimFunc: ...