# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
"""FFI APIs for tvm.meta_schedule"""
# tvm-ffi-stubgen(begin): import-section
# fmt: off
# isort: off
from __future__ import annotations
from tvm_ffi import init_ffi_api as _FFI_INIT_FUNC
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from collections.abc import Mapping, Sequence
    from ctypes import c_void_p
    from ir import FloatImm, IRModule, IntImm
    from meta_schedule import ArgInfo, Builder, BuilderInput, BuilderResult, CostModel, Database, EvolutionarySearch, ExtractedTask, FeatureExtractor, MeasureCallback, MeasureCandidate, Mutator, Postproc, Profiler, Runner, RunnerFuture, RunnerInput, RunnerResult, ScheduleRule, SearchStrategy, SpaceGenerator, TaskScheduler, TensorInfo, TuneContext, TuningRecord, Workload
    from target import Target
    from tir import BlockRV, PrimFunc, Schedule, Trace
    from tvm_ffi import Object, Shape, Tensor, dtype
    from typing import Any, Callable
# isort: on
# fmt: on
# tvm-ffi-stubgen(end)


# tvm-ffi-stubgen(begin): global/meta_schedule
# fmt: off
_FFI_INIT_FUNC("meta_schedule", __name__)
if TYPE_CHECKING:
    def ArgInfoAsJSON(_0: ArgInfo, /) -> Object: ...
    def ArgInfoFromEntryFunc(_0: IRModule, _1: bool, /) -> Sequence[ArgInfo]: ...
    def ArgInfoFromJSON(_0: Object, /) -> ArgInfo: ...
    def ArgInfoFromPrimFunc(_0: PrimFunc, /) -> Sequence[ArgInfo]: ...
    def BuilderBuild(_0: Builder, _1: Sequence[BuilderInput], /) -> Sequence[BuilderResult]: ...
    def BuilderInput(_0: IRModule, _1: Target, _2: Mapping[str, Tensor] | None, /) -> BuilderInput: ...
    def BuilderPyBuilder(_0: Callable[[Sequence[BuilderInput]], Sequence[BuilderResult]], /) -> Builder: ...
    def BuilderResult(_0: str | None, _1: str | None, /) -> BuilderResult: ...
    def CostModelLoad(_0: CostModel, _1: str, /) -> None: ...
    def CostModelPredict(_0: CostModel, _1: TuneContext, _2: Sequence[MeasureCandidate], _3: c_void_p, /) -> None: ...
    def CostModelPyCostModel(_0: Callable[[str], None], _1: Callable[[str], None], _2: Callable[[TuneContext, Sequence[MeasureCandidate], Sequence[RunnerResult]], None], _3: Callable[[TuneContext, Sequence[MeasureCandidate], c_void_p], None], _4: Callable[[], str], /) -> CostModel: ...
    def CostModelSave(_0: CostModel, _1: str, /) -> None: ...
    def CostModelUpdate(_0: CostModel, _1: TuneContext, _2: Sequence[MeasureCandidate], _3: Sequence[RunnerResult], /) -> None: ...
    def DatabaseCommitTuningRecord(_0: Database, _1: TuningRecord, /) -> None: ...
    def DatabaseCommitWorkload(_0: Database, _1: IRModule, /) -> Workload: ...
    def DatabaseCurrent() -> Database | None: ...
    def DatabaseDumpPruned(_0: Database, _1: Database, /) -> None: ...
    def DatabaseEnterWithScope(_0: Database, /) -> None: ...
    def DatabaseExitWithScope(_0: Database, /) -> None: ...
    def DatabaseGetAllTuningRecords(_0: Database, /) -> Sequence[TuningRecord]: ...
    def DatabaseGetTopK(_0: Database, _1: Workload, _2: int, /) -> Sequence[TuningRecord]: ...
    def DatabaseHasWorkload(_0: Database, _1: IRModule, /) -> bool: ...
    def DatabaseJSONDatabase(_0: str, _1: str, _2: bool, _3: str, /) -> Database: ...
    def DatabaseMemoryDatabase(_0: str, /) -> Database: ...
    def DatabaseOrderedUnionDatabase(_0: Sequence[Database], /) -> Database: ...
    def DatabasePyDatabase(_0: Callable[[IRModule], bool], _1: Callable[[IRModule], Workload], _2: Callable[[TuningRecord], None], _3: Callable[[Workload, int], Sequence[TuningRecord]], _4: Callable[[], Sequence[TuningRecord]], _5: Callable[[IRModule, Target, str], TuningRecord | None], _6: Callable[[IRModule, Target, str], Schedule | None], _7: Callable[[IRModule, Target, str], IRModule | None], _8: Callable[[], int], _9: str, /) -> Database: ...
    def DatabaseQueryIRModule(_0: Database, _1: IRModule, _2: Target, _3: str, /) -> IRModule | None: ...
    def DatabaseQuerySchedule(_0: Database, _1: IRModule, _2: Target, _3: str, /) -> Schedule | None: ...
    def DatabaseQueryTuningRecord(_0: Database, _1: IRModule, _2: Target, _3: str, /) -> TuningRecord | None: ...
    def DatabaseScheduleFnDatabase(_0: Callable[[Schedule], bool], _1: str, /) -> Database: ...
    def DatabaseSize(_0: Database, /) -> int: ...
    def DatabaseUnionDatabase(_0: Sequence[Database], /) -> Database: ...
    def ExtractedTask(_0: str, _1: IRModule, _2: Target, _3: Sequence[IRModule], _4: int, /) -> ExtractedTask: ...
    def FeatureExtractorExtractFrom(_0: FeatureExtractor, _1: TuneContext, _2: Sequence[MeasureCandidate], /) -> Sequence[Tensor]: ...
    def FeatureExtractorPerStoreFeature(_0: int, _1: int, _2: int, _3: bool, /) -> FeatureExtractor: ...
    def FeatureExtractorPyFeatureExtractor(_0: Callable[[TuneContext, Sequence[MeasureCandidate]], Sequence[Tensor]], _1: Callable[[], str], /) -> FeatureExtractor: ...
    def MeasureCallbackAddToDatabase() -> MeasureCallback: ...
    def MeasureCallbackApply(_0: MeasureCallback, _1: TaskScheduler, _2: int, _3: Sequence[MeasureCandidate], _4: Sequence[BuilderResult], _5: Sequence[RunnerResult], /) -> None: ...
    def MeasureCallbackDefault() -> Sequence[MeasureCallback]: ...
    def MeasureCallbackPyMeasureCallback(_0: Callable[[TaskScheduler, int, Sequence[MeasureCandidate], Sequence[BuilderResult], Sequence[RunnerResult]], None], _1: Callable[[], str], /) -> MeasureCallback: ...
    def MeasureCallbackRemoveBuildArtifact() -> MeasureCallback: ...
    def MeasureCallbackUpdateCostModel() -> MeasureCallback: ...
    def MeasureCandidate(_0: Schedule, _1: Sequence[ArgInfo] | None, /) -> MeasureCandidate: ...
    def MutateThreadBinding() -> Mutator: ...
    def MutatorApply(_0: Mutator, _1: Trace, _2: int, /) -> Trace | None: ...
    def MutatorClone(_0: Mutator, /) -> Mutator: ...
    def MutatorDefaultCUDA() -> Mapping[Mutator, FloatImm]: ...
    def MutatorDefaultCUDATensorCore() -> Mapping[Mutator, FloatImm]: ...
    def MutatorDefaultHexagon() -> Mapping[Mutator, FloatImm]: ...
    def MutatorDefaultLLVM() -> Mapping[Mutator, FloatImm]: ...
    def MutatorInitializeWithTuneContext(_0: Mutator, _1: TuneContext, /) -> None: ...
    def MutatorMutateComputeLocation() -> Mutator: ...
    def MutatorMutateParallel(_0: int, /) -> Mutator: ...
    def MutatorMutateTileSize() -> Mutator: ...
    def MutatorMutateUnroll() -> Mutator: ...
    def MutatorPyMutator(_0: Callable[[TuneContext], None], _1: Callable[[Trace, int], Trace | None], _2: Callable[[], Mutator], _3: Callable[[], str], /) -> Mutator: ...
    def PostprocApply(_0: Postproc, _1: Schedule, /) -> bool: ...
    def PostprocClone(_0: Postproc, /) -> Postproc: ...
    def PostprocDefaultCUDA() -> Sequence[Postproc]: ...
    def PostprocDefaultCUDATensorCore() -> Sequence[Postproc]: ...
    def PostprocDefaultHexagon() -> Sequence[Postproc]: ...
    def PostprocDefaultLLVM() -> Sequence[Postproc]: ...
    def PostprocDisallowAsyncStridedMemCopy() -> Postproc: ...
    def PostprocDisallowDynamicLoop() -> Postproc: ...
    def PostprocInitializeWithTuneContext(_0: Postproc, _1: TuneContext, /) -> None: ...
    def PostprocPyPostproc(_0: Callable[[TuneContext], None], _1: Callable[[Schedule], bool], _2: Callable[[], Postproc], _3: Callable[[], str], /) -> Postproc: ...
    def PostprocRewriteCooperativeFetch() -> Postproc: ...
    def PostprocRewriteLayout() -> Postproc: ...
    def PostprocRewriteParallelVectorizeUnroll() -> Postproc: ...
    def PostprocRewriteReductionBlock() -> Postproc: ...
    def PostprocRewriteTensorize(_0: bool, /) -> Postproc: ...
    def PostprocRewriteUnboundBlock(_0: int, /) -> Postproc: ...
    def PostprocVerifyGPUCode() -> Postproc: ...
    def PostprocVerifyVTCMLimit() -> Postproc: ...
    def Profiler() -> Profiler: ...
    def ProfilerCurrent() -> Profiler | None: ...
    def ProfilerEnterWithScope(_0: Profiler, /) -> None: ...
    def ProfilerExitWithScope(_0: Profiler, /) -> None: ...
    def ProfilerGet(_0: Profiler, /) -> Mapping[str, FloatImm]: ...
    def ProfilerTable(_0: Profiler, /) -> str: ...
    def ProfilerTimedScope(_0: str, /) -> Callable[..., Any]: ...
    def RunnerFuture(_0: Callable[[], bool], _1: Callable[[], RunnerResult], /) -> RunnerFuture: ...
    def RunnerFutureDone(_0: RunnerFuture, /) -> bool: ...
    def RunnerFutureResult(_0: RunnerFuture, /) -> RunnerResult: ...
    def RunnerInput(_0: str, _1: str, _2: Sequence[ArgInfo], /) -> RunnerInput: ...
    def RunnerPyRunner(_0: Callable[[Sequence[RunnerInput]], Sequence[RunnerFuture]], /) -> Runner: ...
    def RunnerResult(_0: Sequence[FloatImm] | None, _1: str | None, /) -> RunnerResult: ...
    def RunnerRun(_0: Runner, _1: Sequence[RunnerInput], /) -> Sequence[RunnerFuture]: ...
    def ScheduleRuleAddRFactor(_0: int, _1: IntImm | None, /) -> ScheduleRule: ...
    def ScheduleRuleApply(_0: ScheduleRule, _1: Schedule, _2: BlockRV, /) -> Sequence[Schedule]: ...
    def ScheduleRuleApplyCustomRule() -> ScheduleRule: ...
    def ScheduleRuleAutoBind(_0: int, _1: Sequence[IntImm], _2: int, /) -> ScheduleRule: ...
    def ScheduleRuleAutoInline(_0: bool, _1: bool, _2: bool, _3: bool, _4: bool, _5: bool, _6: Sequence[str] | None, /) -> ScheduleRule: ...
    def ScheduleRuleClone(_0: ScheduleRule, /) -> ScheduleRule: ...
    def ScheduleRuleCrossThreadReduction(_0: Sequence[IntImm], /) -> ScheduleRule: ...
    def ScheduleRuleDefaultARM(_0: str, /) -> Sequence[ScheduleRule]: ...
    def ScheduleRuleDefaultCUDA() -> Sequence[ScheduleRule]: ...
    def ScheduleRuleDefaultCUDATensorCore() -> Sequence[ScheduleRule]: ...
    def ScheduleRuleDefaultHexagon() -> Sequence[ScheduleRule]: ...
    def ScheduleRuleDefaultLLVM() -> Sequence[ScheduleRule]: ...
    def ScheduleRuleInitializeWithTuneContext(_0: ScheduleRule, _1: TuneContext, /) -> None: ...
    def ScheduleRuleInlineConstantScalars() -> ScheduleRule: ...
    def ScheduleRuleMultiLevelTiling(_0: str, _1: Sequence[str] | None, _2: IntImm | None, _3: Sequence[IntImm] | None, _4: Mapping[str, Any] | None, _5: Mapping[str, Any] | None, _6: Callable[..., Any] | None, /) -> ScheduleRule: ...
    def ScheduleRuleMultiLevelTilingTensorCore(_0: Sequence[Mapping[str, str]], _1: str, _2: Sequence[str] | None, _3: IntImm | None, _4: Sequence[IntImm] | None, _5: Mapping[str, Any] | None, _6: Mapping[str, Any] | None, _7: bool, /) -> ScheduleRule: ...
    def ScheduleRuleMultiLevelTilingWideVector(_0: str, _1: IntImm, _2: IntImm | None, _3: Mapping[str, Any] | None, _4: Mapping[str, Any] | None, /) -> ScheduleRule: ...
    def ScheduleRuleMultiLevelTilingWithIntrin(_0: str, _1: str, _2: Sequence[str] | None, _3: IntImm | None, _4: Sequence[IntImm] | None, _5: Mapping[str, Any] | None, _6: Mapping[str, Any] | None, /) -> ScheduleRule: ...
    def ScheduleRuleParallelizeVectorizeUnroll(_0: int, _1: int, _2: Sequence[IntImm], _3: bool, /) -> ScheduleRule: ...
    def ScheduleRulePyScheduleRule(_0: Callable[[TuneContext], None], _1: Callable[[Schedule, BlockRV], Sequence[Schedule]], _2: Callable[[], ScheduleRule], _3: Callable[[], str], /) -> ScheduleRule: ...
    def ScheduleRuleRandomComputeLocation() -> ScheduleRule: ...
    def ScheduleUsingAnchorTrace(_0: Schedule, _1: Trace, _2: Target, /) -> None: ...
    def SearchStrategyClone(_0: SearchStrategy, /) -> SearchStrategy: ...
    def SearchStrategyEvolutionarySearch(_0: int, _1: float, _2: int, _3: int, _4: int, _5: float, _6: int, _7: float, /) -> SearchStrategy: ...
    def SearchStrategyEvolutionarySearchEvolveWithCostModel(_0: EvolutionarySearch, _1: Sequence[Schedule], _2: int, /) -> Sequence[Schedule]: ...
    def SearchStrategyEvolutionarySearchSampleInitPopulation(_0: EvolutionarySearch, _1: int, /) -> Sequence[Schedule]: ...
    def SearchStrategyGenerateMeasureCandidates(_0: SearchStrategy, /) -> Sequence[MeasureCandidate] | None: ...
    def SearchStrategyInitializeWithTuneContext(_0: SearchStrategy, _1: TuneContext, /) -> None: ...
    def SearchStrategyNotifyRunnerResults(_0: SearchStrategy, _1: Sequence[MeasureCandidate], _2: Sequence[RunnerResult], /) -> None: ...
    def SearchStrategyPostTuning(_0: SearchStrategy, /) -> None: ...
    def SearchStrategyPreTuning(_0: SearchStrategy, _1: int, _2: int, _3: Sequence[Schedule], _4: Database | None, _5: CostModel | None, /) -> None: ...
    def SearchStrategyPySearchStrategy(_0: Callable[[TuneContext], None], _1: Callable[[int, int, Sequence[Schedule], Database | None, CostModel | None], None], _2: Callable[[], None], _3: Callable[[], Sequence[MeasureCandidate] | None], _4: Callable[[Sequence[MeasureCandidate], Sequence[RunnerResult]], None], _5: Callable[[], SearchStrategy], /) -> SearchStrategy: ...
    def SearchStrategyReplayFunc() -> SearchStrategy: ...
    def SearchStrategyReplayTrace(_0: int, /) -> SearchStrategy: ...
    def SpaceGeneratorClone(_0: SpaceGenerator, /) -> SpaceGenerator: ...
    def SpaceGeneratorGenerateDesignSpace(_0: SpaceGenerator, _1: IRModule, /) -> Sequence[Schedule]: ...
    def SpaceGeneratorInitializeWithTuneContext(_0: SpaceGenerator, _1: TuneContext, /) -> None: ...
    def SpaceGeneratorPostOrderApply(_0: Callable[..., Any], _1: Sequence[ScheduleRule] | None, _2: Sequence[Postproc] | None, _3: Mapping[Mutator, FloatImm] | None, /) -> SpaceGenerator: ...
    def SpaceGeneratorPySpaceGenerator(_0: Sequence[ScheduleRule] | None, _1: Sequence[Postproc] | None, _2: Mapping[Mutator, FloatImm] | None, _3: Callable[[TuneContext], None], _4: Callable[[IRModule], Sequence[Schedule]], _5: Callable[[], SpaceGenerator], /) -> SpaceGenerator: ...
    def SpaceGeneratorScheduleFn(_0: Callable[..., Any], _1: Sequence[ScheduleRule] | None, _2: Sequence[Postproc] | None, _3: Mapping[Mutator, FloatImm] | None, /) -> SpaceGenerator: ...
    def SpaceGeneratorSpaceGeneratorUnion(_0: Sequence[SpaceGenerator], _1: Sequence[ScheduleRule] | None, _2: Sequence[Postproc] | None, _3: Mapping[Mutator, FloatImm] | None, /) -> SpaceGenerator: ...
    def TaskSchedulerGradientBased(_0: Callable[..., Any], _1: float, _2: int, _3: int, /) -> TaskScheduler: ...
    def TaskSchedulerJoinRunningTask(_0: TaskScheduler, _1: int, /) -> Sequence[RunnerResult]: ...
    def TaskSchedulerNextTaskId(_0: TaskScheduler, /) -> int: ...
    def TaskSchedulerPrintTuningStatistics(_0: TaskScheduler, /) -> None: ...
    def TaskSchedulerPyTaskScheduler(_0: Callable[..., Any], _1: Callable[[], int], _2: Callable[[int], Sequence[RunnerResult]], _3: Callable[[Sequence[TuneContext], Sequence[FloatImm], int, int, int, Builder, Runner, Sequence[MeasureCallback], Database | None, CostModel | None], None], /) -> TaskScheduler: ...
    def TaskSchedulerRoundRobin(_0: Callable[..., Any], /) -> TaskScheduler: ...
    def TaskSchedulerTerminateTask(_0: TaskScheduler, _1: int, /) -> None: ...
    def TaskSchedulerTouchTask(_0: TaskScheduler, _1: int, /) -> None: ...
    def TaskSchedulerTune(_0: TaskScheduler, _1: Sequence[TuneContext], _2: Sequence[FloatImm], _3: int, _4: int, _5: int, _6: Builder, _7: Runner, _8: Sequence[MeasureCallback], _9: Database | None, _10: CostModel | None, /) -> None: ...
    def TensorInfo(_0: dtype, _1: Shape, /) -> TensorInfo: ...
    def TuneContext(_0: IRModule | None, _1: Target | None, _2: SpaceGenerator | None, _3: SearchStrategy | None, _4: str | None, _5: int, _6: int, _7: Callable[..., Any], /) -> TuneContext: ...
    def TuneContextClone(_0: TuneContext, /) -> TuneContext: ...
    def TuneContextInitialize(_0: TuneContext, /) -> None: ...
    def TuningRecord(_0: Trace, _1: Workload, _2: Sequence[FloatImm] | None, _3: Target | None, _4: Sequence[ArgInfo] | None, /) -> TuningRecord: ...
    def TuningRecordAsJSON(_0: TuningRecord, /) -> Object: ...
    def TuningRecordAsMeasureCandidate(_0: TuningRecord, /) -> MeasureCandidate: ...
    def TuningRecordFromJSON(_0: Object, _1: Workload, /) -> TuningRecord: ...
    def Workload(_0: IRModule, /) -> Workload: ...
    def WorkloadAsJSON(_0: Workload, /) -> Object: ...
    def WorkloadFromJSON(_0: Object, /) -> Workload: ...
    def _SHash2Hex(_0: Object, /) -> str: ...
# fmt: on
# tvm-ffi-stubgen(end)
