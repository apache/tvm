# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
"""FFI APIs for tvm.tir.schedule"""
# tvm-ffi-stubgen(begin): import-section
# fmt: off
# isort: off
from __future__ import annotations
from tvm_ffi import init_ffi_api as _FFI_INIT_FUNC
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from collections.abc import Mapping, Sequence
    from ir import FloatImm, GlobalVar, IRModule, IntImm, PrimExpr
    from tir import Block, BlockRV, BlockRealize, BlockScope, Buffer, For, IndexMap, Instruction, InstructionKind, LoopRV, PrimFunc, Schedule, ScheduleState, Stmt, StmtSRef, Trace
    from tir.schedule import AutoTensorizeMappingInfo, TensorizeInfo
    from tvm_ffi import Object
    from typing import Any, Callable
# isort: on
# fmt: on
# tvm-ffi-stubgen(end)


# tvm-ffi-stubgen(begin): global/tir.schedule
# fmt: off
_FFI_INIT_FUNC("tir.schedule", __name__)
if TYPE_CHECKING:
    def BlockRV() -> BlockRV: ...
    def CanDecomposePadding(_0: Schedule, _1: BlockRV, _2: LoopRV, /) -> bool: ...
    def ConcreteSchedule(_0: IRModule, _1: int, _2: int, _3: int, _4: bool, /) -> Schedule: ...
    def GetAutoTensorizeMappingInfo(_0: Schedule, _1: BlockRV, _2: PrimFunc, /) -> AutoTensorizeMappingInfo | None: ...
    def GetBlockRealize(_0: Schedule, _1: BlockRV, /) -> BlockRealize: ...
    def GetLoopIterType(_0: Schedule, _1: LoopRV, /) -> str: ...
    def GetTensorizeLoopMapping(_0: Schedule, _1: BlockRV, _2: PrimFunc, _3: bool, /) -> TensorizeInfo | None: ...
    def HasBlock(_0: Schedule, _1: str, /) -> bool: ...
    def HasIfThenElse(_0: Stmt, /) -> bool: ...
    def Instruction(_0: InstructionKind, _1: Sequence[Any], _2: Sequence[Any], _3: Sequence[Any], /) -> Instruction: ...
    def InstructionKindGet(_0: str, /) -> InstructionKind: ...
    def IsOutputBlock(_0: Schedule, _1: BlockRV, /) -> bool: ...
    def IsReductionBlock(_0: Schedule, _1: BlockRV, _2: BlockRV, /) -> bool: ...
    def IsSpatialPrimFunc(_0: PrimFunc, /) -> bool: ...
    def IsTrivialBinding(_0: Schedule, _1: BlockRV, /) -> bool: ...
    def LoopRV() -> LoopRV: ...
    def NormalizePrimFunc(_0: Schedule, /) -> Object | None: ...
    def RegisterReducer(_0: int, _1: Callable[..., Any], _2: Callable[..., Any], /) -> None: ...
    def ScheduleAddUnitLoop(_0: Schedule, _1: Object, /) -> LoopRV: ...
    def ScheduleAnnotate(_0: Schedule, _1: Object, _2: str, _3: Any, /) -> None: ...
    def ScheduleAnnotateBufferAccess(_0: Schedule, _1: BlockRV, _2: int, _3: int, _4: IndexMap, /) -> None: ...
    def ScheduleBind(_0: Schedule, _1: LoopRV, _2: str, /) -> None: ...
    def ScheduleBlockize(_0: Schedule, _1: Object, _2: bool, /) -> BlockRV: ...
    def ScheduleCacheIndex(_0: Schedule, _1: BlockRV, _2: str, _3: int, /) -> Sequence[BlockRV]: ...
    def ScheduleCacheInplace(_0: Schedule, _1: BlockRV, _2: int, _3: str, /) -> Sequence[BlockRV]: ...
    def ScheduleCacheRead(_0: Schedule, _1: BlockRV, _2: int, _3: str, _4: Sequence[BlockRV], /) -> BlockRV: ...
    def ScheduleCacheWrite(_0: Schedule, _1: BlockRV, _2: int, _3: str, _4: Sequence[BlockRV], /) -> BlockRV: ...
    def ScheduleComputeAt(_0: Schedule, _1: BlockRV, _2: LoopRV, _3: bool, _4: int, /) -> None: ...
    def ScheduleComputeInline(_0: Schedule, _1: BlockRV, /) -> None: ...
    def ScheduleCopy(_0: Schedule, /) -> Schedule: ...
    def ScheduleDecomposePadding(_0: Schedule, _1: BlockRV, _2: LoopRV, /) -> BlockRV: ...
    def ScheduleDecomposeReduction(_0: Schedule, _1: BlockRV, _2: LoopRV, /) -> BlockRV: ...
    def ScheduleEnterPostproc(_0: Schedule, /) -> None: ...
    def ScheduleForkSeed(_0: Schedule, /) -> int: ...
    def ScheduleFuse(_0: Schedule, _1: Sequence[LoopRV], _2: bool, /) -> LoopRV: ...
    def ScheduleFuseReductionEpilogue(_0: Schedule, _1: BlockRV, _2: BlockRV, /) -> None: ...
    def ScheduleGet(_0: Schedule, _1: Object, /) -> Object: ...
    def ScheduleGetBlock(_0: Schedule, _1: str, _2: str | None, /) -> BlockRV: ...
    def ScheduleGetChildBlocks(_0: Schedule, _1: Object, /) -> Sequence[BlockRV]: ...
    def ScheduleGetConsumers(_0: Schedule, _1: BlockRV, /) -> Sequence[BlockRV]: ...
    def ScheduleGetFuncWorkingOn(_0: Schedule, /) -> GlobalVar | None: ...
    def ScheduleGetLoops(_0: Schedule, _1: BlockRV, /) -> Sequence[LoopRV]: ...
    def ScheduleGetMod(_0: Schedule, /) -> IRModule: ...
    def ScheduleGetOutputBlocks(_0: Schedule, _1: BlockRV, /) -> Sequence[BlockRV]: ...
    def ScheduleGetProducers(_0: Schedule, _1: BlockRV, /) -> Sequence[BlockRV]: ...
    def ScheduleGetSRef(_0: Schedule, _1: Object, /) -> Object | None: ...
    def ScheduleGetState(_0: Schedule, /) -> ScheduleState: ...
    def ScheduleGetTrace(_0: Schedule, /) -> Trace | None: ...
    def ScheduleLoopPartition(_0: Schedule, _1: LoopRV, _2: Sequence[PrimExpr | None], _3: bool, /) -> Sequence[LoopRV]: ...
    def ScheduleMerge(_0: Schedule, _1: Sequence[LoopRV], /) -> LoopRV: ...
    def SchedulePadEinsum(_0: Schedule, _1: BlockRV, _2: Sequence[IntImm], /) -> None: ...
    def ScheduleParallel(_0: Schedule, _1: LoopRV, /) -> None: ...
    def ScheduleRFactor(_0: Schedule, _1: LoopRV, _2: int, /) -> BlockRV: ...
    def ScheduleReIndex(_0: Schedule, _1: BlockRV, _2: int, _3: int, /) -> BlockRV: ...
    def ScheduleReadAt(_0: Schedule, _1: LoopRV, _2: BlockRV, _3: int, _4: str, /) -> BlockRV: ...
    def ScheduleReindexCacheRead(_0: Schedule, _1: BlockRV, _2: int, _3: str, _4: IndexMap, /) -> BlockRV: ...
    def ScheduleReindexCacheWrite(_0: Schedule, _1: BlockRV, _2: int, _3: str, _4: IndexMap, /) -> BlockRV: ...
    def ScheduleRemoveRV(_0: Schedule, _1: Object, /) -> None: ...
    def ScheduleReorder(_0: Schedule, _1: Sequence[LoopRV], /) -> None: ...
    def ScheduleReorderBlockIterVar(_0: Schedule, _1: BlockRV, _2: Sequence[IntImm], /) -> None: ...
    def ScheduleReverseComputeAt(_0: Schedule, _1: BlockRV, _2: LoopRV, _3: bool, _4: int, /) -> None: ...
    def ScheduleReverseComputeInline(_0: Schedule, _1: BlockRV, /) -> None: ...
    def ScheduleRollingBuffer(_0: Schedule, _1: BlockRV, _2: int, /) -> None: ...
    def ScheduleSampleCategorical(_0: Schedule, _1: Sequence[IntImm], _2: Sequence[FloatImm], _3: IntImm | None, /) -> PrimExpr: ...
    def ScheduleSampleComputeLocation(_0: Schedule, _1: BlockRV, _2: IntImm | None, /) -> LoopRV: ...
    def ScheduleSamplePartitionedTile(_0: Schedule, _1: LoopRV, _2: int, _3: int, _4: int, _5: Sequence[IntImm] | None, /) -> Sequence[PrimExpr]: ...
    def ScheduleSamplePerfectTile(_0: Schedule, _1: LoopRV, _2: int, _3: int, _4: Sequence[IntImm] | None, /) -> Sequence[PrimExpr]: ...
    def ScheduleSeed(_0: Schedule, _1: int, /) -> None: ...
    def ScheduleSetAxisSeparator(_0: Schedule, _1: BlockRV, _2: int, _3: int, _4: Sequence[IntImm], /) -> None: ...
    def ScheduleSetScope(_0: Schedule, _1: BlockRV, _2: int, _3: str, /) -> None: ...
    def ScheduleSplit(_0: Schedule, _1: LoopRV, _2: Sequence[PrimExpr | None], _3: bool, _4: bool, /) -> Sequence[LoopRV]: ...
    def ScheduleState(_0: IRModule, _1: int, _2: bool, /) -> ScheduleState: ...
    def ScheduleStateGetBlockScope(_0: ScheduleState, _1: StmtSRef, /) -> BlockScope: ...
    def ScheduleStateGetCachedFlags(_0: ScheduleState, _1: StmtSRef, /) -> Sequence[IntImm]: ...
    def ScheduleStateGetSRef(_0: ScheduleState, _1: Stmt, /) -> StmtSRef | None: ...
    def ScheduleStateReplace(_0: ScheduleState, _1: StmtSRef, _2: Stmt, _3: Mapping[Block, Block], /) -> None: ...
    def ScheduleStorageAlign(_0: Schedule, _1: BlockRV, _2: int, _3: int, _4: int, _5: int, /) -> None: ...
    def ScheduleTensorize(_0: Schedule, _1: Object, _2: str, _3: bool, /) -> None: ...
    def ScheduleTransformBlockLayout(_0: Schedule, _1: BlockRV, _2: IndexMap, /) -> None: ...
    def ScheduleTransformLayout(_0: Schedule, _1: BlockRV, _2: int, _3: int, _4: IndexMap, _5: IndexMap | None, _6: bool, /) -> None: ...
    def ScheduleUnannotate(_0: Schedule, _1: Object, _2: str, /) -> None: ...
    def ScheduleUnroll(_0: Schedule, _1: LoopRV, /) -> None: ...
    def ScheduleUnsafeHideBufferAccess(_0: Schedule, _1: BlockRV, _2: str, _3: Sequence[IntImm], /) -> None: ...
    def ScheduleUnsafeSetDType(_0: Schedule, _1: BlockRV, _2: int, _3: str, /) -> None: ...
    def ScheduleVectorize(_0: Schedule, _1: LoopRV, /) -> None: ...
    def ScheduleWorkOn(_0: Schedule, _1: str, /) -> None: ...
    def ScheduleWriteAt(_0: Schedule, _1: LoopRV, _2: BlockRV, _3: int, _4: str, /) -> BlockRV: ...
    def SuggestIndexMap(_0: Buffer, _1: Sequence[PrimExpr], _2: Sequence[For], _3: PrimExpr, /) -> IndexMap | None: ...
    def TileWithTensorIntrin(_0: Schedule, _1: BlockRV, _2: str, _3: bool, /) -> LoopRV | None: ...
    def Trace(_0: Sequence[Instruction] | None, _1: Mapping[Instruction, Any] | None, /) -> Trace: ...
    def TraceAppend(_0: Trace, _1: Instruction, _2: Object | None, /) -> None: ...
    def TraceApplyJSONToSchedule(_0: Object, _1: Schedule, /) -> None: ...
    def TraceApplyToSchedule(_0: Trace, _1: Schedule, _2: bool, _3: Callable[[Instruction, Sequence[Any], Sequence[Any], Any], Any], /) -> None: ...
    def TraceAsJSON(_0: Trace, _1: bool, /) -> Object: ...
    def TraceAsPython(_0: Trace, _1: bool, /) -> Sequence[str]: ...
    def TraceGetDecision(_0: Trace, _1: Instruction, /) -> Any: ...
    def TracePop(_0: Trace, /) -> Instruction | None: ...
    def TraceSimplified(_0: Trace, _1: bool, /) -> Trace: ...
    def TraceWithDecision(_0: Trace, _1: Instruction, _2: Any, _3: bool, /) -> Trace: ...
    def TracedSchedule(_0: IRModule, _1: int, _2: int, _3: int, _4: bool, /) -> Schedule: ...
# fmt: on
# tvm-ffi-stubgen(end)
