# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
"""FFI APIs from C++"""
# tvm-ffi-stubgen(begin): import-section
# fmt: off
# isort: off
from __future__ import annotations
from tvm_ffi import init_ffi_api as _FFI_INIT_FUNC
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from collections.abc import Sequence
    from runtime.disco import DRef, Session
    from tvm_ffi import Device, Module, Object, Shape, Tensor, dtype
    from typing import Any
# isort: on
# fmt: on
# tvm-ffi-stubgen(end)


# tvm-ffi-stubgen(begin): global/runtime.disco
# fmt: off
_FFI_INIT_FUNC("runtime.disco", __name__)
if TYPE_CHECKING:
    def DRefDebugCopyFrom(_0: DRef, _1: int, _2: Any, /) -> None: ...
    def DRefDebugGetFromRemote(_0: DRef, _1: int, /) -> Any: ...
    def RemoteSocketSession(_0: str, _1: int, _2: int, /) -> None: ...
    def SessionCallPacked(*args: Any) -> Any: ...
    def SessionCopyFromWorker0(_0: Session, _1: Tensor, _2: DRef, /) -> None: ...
    def SessionCopyToWorker0(_0: Session, _1: Tensor, _2: DRef, /) -> None: ...
    def SessionGetGlobalFunc(_0: Session, _1: str, /) -> DRef: ...
    def SessionGetNumWorkers(_0: Session, /) -> int: ...
    def SessionInitCCL(_0: Session, _1: str, _2: Shape, /) -> None: ...
    def SessionProcess(_0: int, _1: int, _2: str, _3: str, /) -> Session: ...
    def SessionShutdown(_0: Session, /) -> None: ...
    def SessionSyncWorker(_0: Session, _1: int, /) -> None: ...
    def SessionThreaded(_0: int, _1: int, /) -> Session: ...
    def ShardLoader(_0: str, _1: str, _2: str, _3: Module | None, /) -> Object: ...
    def ShardLoaderLoad(_0: Object, _1: Shape, /) -> Tensor: ...
    def ShardLoaderLoadAll(_0: Object, /) -> Sequence[Tensor]: ...
    def ShardLoaderLoadAllPresharded(_0: Object, /) -> Sequence[Tensor]: ...
    def ShardLoaderLoadParamOnWorker0(_0: Object, _1: int, /) -> Tensor: ...
    def ShardLoaderLoadPresharded(_0: Object, _1: Shape, /) -> Tensor: ...
    def SocketSession(_0: int, _1: int, _2: int, _3: str, _4: int, /) -> Session: ...
    def WorkerProcess(_0: int, _1: int, _2: int, _3: int, _4: int, /) -> None: ...
    def allgather(_0: Tensor, _1: bool, _2: Tensor, /) -> None: ...
    def allreduce(_0: Tensor, _1: Shape, _2: bool, _3: Tensor, /) -> None: ...
    def bind_worker_to_cpu_core(_0: Shape, /) -> None: ...
    def broadcast_from_worker0(_0: Tensor, _1: bool, _2: Tensor, /) -> None: ...
    def device() -> Device: ...
    def empty(_0: Shape, _1: dtype, _2: Device | None, _3: bool, _4: bool, /) -> Tensor | None: ...
    def gather_to_worker0(_0: Tensor, _1: bool, _2: Tensor | None, /) -> None: ...
    def load_vm_module(_0: str, _1: Device | None, /) -> Module: ...
    def recv_from_prev_group(_0: Tensor, /) -> None: ...
    def recv_from_worker(_0: Tensor, _1: int, /) -> None: ...
    def recv_from_worker0(_0: Tensor, /) -> None: ...
    def scatter_from_worker0(_0: Tensor | None, _1: bool, _2: Tensor, /) -> None: ...
    def send_to_next_group(_0: Tensor, /) -> None: ...
    def send_to_worker(_0: Tensor, _1: int, /) -> None: ...
    def socket_session_init_workers(_0: int, _1: int, _2: int, _3: int, /) -> None: ...
    def worker_id() -> Shape: ...
    def worker_rank() -> int: ...
# fmt: on
# tvm-ffi-stubgen(end)
