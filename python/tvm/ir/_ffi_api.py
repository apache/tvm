# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
"""FFI APIs for tvm.ir"""
# tvm-ffi-stubgen(begin): import-section
# fmt: off
# isort: off
from __future__ import annotations
from tvm_ffi import init_ffi_api as _FFI_INIT_FUNC
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from collections.abc import Mapping, Sequence
    from ir import BaseFunc, DictAttrs, DummyGlobalInfo, EnvFunc, FloatImm, FuncType, GlobalInfo, GlobalVar, GlobalVarSupply, IRModule, IntImm, NameSupply, Op, PointerType, PrimExpr, PrimType, Range, RelaxExpr, SequentialSpan, SourceName, Span, StructInfo, TensorMapType, TupleType, Type, VDevice
    from target import Target
    from tvm_ffi import Object, dtype
    from typing import Any, Callable
# isort: on
# fmt: on
# tvm-ffi-stubgen(end)



# tvm-ffi-stubgen(begin): global/ir
# fmt: off
_FFI_INIT_FUNC("ir", __name__)
if TYPE_CHECKING:
    def BaseFuncCopy(_0: BaseFunc, /) -> BaseFunc: ...
    def BaseFuncWithAttr(_0: ObjectRValueRef[BaseFunc], _1: str, _2: Any, /) -> BaseFunc: ...
    def BaseFuncWithAttrs(_0: ObjectRValueRef[BaseFunc], _1: Mapping[str, Any], /) -> BaseFunc: ...
    def BaseFuncWithoutAttr(_0: ObjectRValueRef[BaseFunc], _1: str, /) -> BaseFunc: ...
    def BaseFunc_Attrs(_0: BaseFunc, /) -> DictAttrs: ...
    def DebugPrint(_0: Object, /) -> str: ...
    def DictAttrsGetDict(_0: DictAttrs, /) -> Mapping[str, Any]: ...
    def DummyGlobalInfo() -> DummyGlobalInfo: ...
    def EnvFuncCall(*args: Any) -> Any: ...
    def EnvFuncGet(_0: str, /) -> EnvFunc: ...
    def EnvFuncGetFunction(_0: EnvFunc, /) -> Callable[..., Any]: ...
    def ExprStructInfo(_0: RelaxExpr, /) -> StructInfo: ...
    def FloatImm(_0: dtype, _1: float, _2: Span, /) -> FloatImm: ...
    def FuncType(_0: Sequence[Type], _1: Type, /) -> FuncType: ...
    def GetOp(_0: str, /) -> Op: ...
    def GlobalVar(_0: str, /) -> GlobalVar: ...
    def GlobalVarSupply_FreshGlobal(_0: GlobalVarSupply, _1: str, _2: bool, /) -> GlobalVar: ...
    def GlobalVarSupply_IRModule(_0: IRModule, /) -> GlobalVarSupply: ...
    def GlobalVarSupply_IRModules(_0: Sequence[IRModule], /) -> GlobalVarSupply: ...
    def GlobalVarSupply_NameSupply(_0: NameSupply, /) -> GlobalVarSupply: ...
    def GlobalVarSupply_ReserveGlobalVar(_0: GlobalVarSupply, _1: GlobalVar, _2: bool, /) -> None: ...
    def GlobalVarSupply_UniqueGlobalFor(_0: GlobalVarSupply, _1: str, _2: bool, /) -> GlobalVar: ...
    def IRModule(_0: Mapping[GlobalVar, BaseFunc], _1: Object, _2: Mapping[str, Sequence[GlobalInfo]], /) -> IRModule: ...
    def IntImm(_0: dtype, _1: int, _2: Span, /) -> IntImm: ...
    def ListOpNames() -> Sequence[str]: ...
    def Module_Add(_0: IRModule, _1: GlobalVar, _2: Object, _3: bool, /) -> IRModule: ...
    def Module_Clone(_0: IRModule, /) -> IRModule: ...
    def Module_ContainGlobalVar(_0: IRModule, _1: str, /) -> bool: ...
    def Module_Contains(_0: IRModule, _1: str | GlobalVar, /) -> bool: ...
    def Module_FromExpr(_0: RelaxExpr, _1: Mapping[GlobalVar, BaseFunc], /) -> IRModule: ...
    def Module_GetAttr(_0: IRModule, _1: str, /) -> Object: ...
    def Module_GetAttrs(_0: IRModule, /) -> Object: ...
    def Module_GetGlobalVar(_0: IRModule, _1: str, /) -> GlobalVar: ...
    def Module_GetGlobalVars(_0: IRModule, /) -> Sequence[GlobalVar]: ...
    def Module_Lookup(_0: IRModule, _1: GlobalVar, /) -> BaseFunc: ...
    def Module_Lookup_str(_0: IRModule, _1: str, /) -> BaseFunc: ...
    def Module_Remove(_0: IRModule, _1: str | GlobalVar, /) -> IRModule: ...
    def Module_ReplaceGlobalVars(_0: IRModule, _1: Mapping[str | GlobalVar, str | GlobalVar], /) -> IRModule: ...
    def Module_Update(_0: IRModule, _1: IRModule, /) -> None: ...
    def Module_UpdateFunction(_0: IRModule, _1: GlobalVar, _2: BaseFunc, /) -> None: ...
    def Module_UpdateGlobalInfo(_0: IRModule, _1: str, _2: Sequence[GlobalInfo], /) -> None: ...
    def Module_WithAttr(_0: ObjectRValueRef[IRModule], _1: str, _2: Any, /) -> IRModule: ...
    def Module_WithAttrs(_0: ObjectRValueRef[IRModule], _1: Mapping[str, Any], /) -> IRModule: ...
    def Module_WithoutAttr(_0: ObjectRValueRef[IRModule], _1: str, /) -> IRModule: ...
    def NameSupply(_0: str, /) -> NameSupply: ...
    def NameSupply_ContainsName(_0: NameSupply, _1: str, _2: bool, /) -> bool: ...
    def NameSupply_FreshName(_0: NameSupply, _1: str, _2: bool, _3: bool, /) -> str: ...
    def NameSupply_ReserveName(_0: NameSupply, _1: str, _2: bool, /) -> str: ...
    def OpAddArgument(_0: Op, _1: str, _2: str, _3: str, /) -> None: ...
    def OpGetAttr(_0: Op, _1: str, /) -> Any: ...
    def OpHasAttr(_0: Op, _1: str, /) -> bool: ...
    def OpResetAttr(_0: Op, _1: str, /) -> None: ...
    def OpSetAttr(_0: Op, _1: str, _2: Any, _3: int, /) -> None: ...
    def OpSetAttrsTypeKey(_0: Op, _1: str, /) -> None: ...
    def OpSetNumInputs(_0: Op, _1: int, /) -> None: ...
    def OpSetSupportLevel(_0: Op, _1: int, /) -> None: ...
    def PointerType(_0: Type, _1: str, /) -> PointerType: ...
    def PrimType(_0: dtype, /) -> PrimType: ...
    def Range(_0: PrimExpr, _1: PrimExpr | None, _2: Span, /) -> Range: ...
    def Range_from_min_extent(_0: PrimExpr, _1: PrimExpr, _2: Span, /) -> Range: ...
    def RegisterOp(_0: str, _1: str, /) -> None: ...
    def RegisterOpAttr(_0: str, _1: str, _2: Any, _3: int, /) -> None: ...
    def RegisterOpLowerIntrinsic(_0: str, _1: Callable[..., Any], _2: str, _3: int, /) -> None: ...
    def SequentialSpan(_0: Sequence[Span], /) -> SequentialSpan: ...
    def SourceName(_0: str, /) -> SourceName: ...
    def Span(_0: SourceName, _1: int, _2: int, _3: int, _4: int, /) -> Span: ...
    def TensorMapType(_0: Span, /) -> TensorMapType: ...
    def TupleType(_0: Sequence[Type], /) -> TupleType: ...
    def VDevice(_0: Target, _1: int, _2: str, /) -> VDevice: ...
# fmt: on
# tvm-ffi-stubgen(end)
