# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
"""FFI APIs for tvm.relax.op"""
# tvm-ffi-stubgen(begin): import-section
# fmt: off
# isort: off
from __future__ import annotations
from tvm_ffi import init_ffi_api as _FFI_INIT_FUNC
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from collections.abc import Mapping, Sequence
    from ir import Attrs, IntImm, PrimExpr, RelaxExpr, StructInfo, VDevice
    from relax import TensorStructInfo
    from relax.expr import PrimValue, StringImm, Tuple
    from tir import IndexMap
    from tvm_ffi import dtype
    from typing import Any
# isort: on
# fmt: on
# tvm-ffi-stubgen(end)


# tvm-ffi-stubgen(begin): global/relax.op
# fmt: off
_FFI_INIT_FUNC("relax.op", __name__)
if TYPE_CHECKING:
    def abs(_0: RelaxExpr, /) -> RelaxExpr: ...
    def acos(_0: RelaxExpr, /) -> RelaxExpr: ...
    def acosh(_0: RelaxExpr, /) -> RelaxExpr: ...
    def add(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def arange(_0: PrimValue, _1: PrimValue, _2: PrimValue, _3: dtype, /) -> RelaxExpr: ...
    def argmax(_0: RelaxExpr, _1: int | None, _2: bool, /) -> RelaxExpr: ...
    def argmin(_0: RelaxExpr, _1: int | None, _2: bool, /) -> RelaxExpr: ...
    def argsort(_0: RelaxExpr, _1: int, _2: bool, _3: dtype, /) -> RelaxExpr: ...
    def asin(_0: RelaxExpr, /) -> RelaxExpr: ...
    def asinh(_0: RelaxExpr, /) -> RelaxExpr: ...
    def assert_op(_0: RelaxExpr, _1: Sequence[RelaxExpr], _2: StringImm, /) -> RelaxExpr: ...
    def astype(_0: RelaxExpr, _1: dtype, /) -> RelaxExpr: ...
    def atan(_0: RelaxExpr, /) -> RelaxExpr: ...
    def atanh(_0: RelaxExpr, /) -> RelaxExpr: ...
    def bitwise_and(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def bitwise_not(_0: RelaxExpr, /) -> RelaxExpr: ...
    def bitwise_or(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def bitwise_xor(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def broadcast_to(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def bucketize(_0: RelaxExpr, _1: RelaxExpr, _2: bool, _3: bool, /) -> RelaxExpr: ...
    def call_builtin_with_ctx(_0: RelaxExpr, _1: Tuple, _2: Sequence[StructInfo], /) -> RelaxExpr: ...
    def call_dps_packed(_0: RelaxExpr, _1: Tuple, _2: Sequence[TensorStructInfo], /) -> RelaxExpr: ...
    def call_inplace_packed(_0: RelaxExpr, _1: Sequence[RelaxExpr], _2: Sequence[IntImm], _3: Sequence[StructInfo], /) -> RelaxExpr: ...
    def call_pure_packed(_0: RelaxExpr, _1: Sequence[RelaxExpr], _2: Attrs, _3: Sequence[StructInfo], /) -> RelaxExpr: ...
    def call_py_func(_0: StringImm, _1: Tuple, _2: Sequence[TensorStructInfo], /) -> RelaxExpr: ...
    def call_tir(_0: RelaxExpr, _1: Tuple, _2: Sequence[TensorStructInfo], _3: RelaxExpr | None, /) -> RelaxExpr: ...
    def call_tir_inplace(_0: RelaxExpr, _1: Tuple, _2: Sequence[IntImm], _3: Sequence[TensorStructInfo], _4: RelaxExpr | None, /) -> RelaxExpr: ...
    def call_tir_with_grad(_0: RelaxExpr, _1: Tuple, _2: Sequence[TensorStructInfo], _3: str, _4: Mapping[str, Any], _5: RelaxExpr | None, /) -> RelaxExpr: ...
    def ceil(_0: RelaxExpr, /) -> RelaxExpr: ...
    def clip(_0: RelaxExpr, _1: RelaxExpr, _2: RelaxExpr, /) -> RelaxExpr: ...
    def collapse_sum_like(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def collapse_sum_to(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def concat(_0: RelaxExpr, _1: int | None, /) -> RelaxExpr: ...
    def cos(_0: RelaxExpr, /) -> RelaxExpr: ...
    def cosh(_0: RelaxExpr, /) -> RelaxExpr: ...
    def cumprod(_0: RelaxExpr, _1: int | None, _2: dtype | None, _3: IntImm, /) -> RelaxExpr: ...
    def cumsum(_0: RelaxExpr, _1: int | None, _2: dtype | None, _3: IntImm, /) -> RelaxExpr: ...
    def dequantize(_0: RelaxExpr, _1: RelaxExpr, _2: RelaxExpr, _3: int, _4: dtype, /) -> RelaxExpr: ...
    def divide(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def dynamic_strided_slice(_0: RelaxExpr, _1: RelaxExpr, _2: RelaxExpr, _3: RelaxExpr, /) -> RelaxExpr: ...
    def einsum(_0: RelaxExpr, _1: str, /) -> RelaxExpr: ...
    def equal(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def erf(_0: RelaxExpr, /) -> RelaxExpr: ...
    def ewise_fma(_0: RelaxExpr, _1: RelaxExpr, _2: RelaxExpr, /) -> RelaxExpr: ...
    def exp(_0: RelaxExpr, /) -> RelaxExpr: ...
    def expand_dims(_0: RelaxExpr, _1: Sequence[IntImm], /) -> RelaxExpr: ...
    def eye(_0: PrimValue, _1: PrimValue, _2: PrimValue, _3: dtype, /) -> RelaxExpr: ...
    def eye_like(_0: RelaxExpr, _1: PrimValue, _2: dtype | None, /) -> RelaxExpr: ...
    def flatten(_0: RelaxExpr, /) -> RelaxExpr: ...
    def flip(_0: RelaxExpr, _1: IntImm, /) -> RelaxExpr: ...
    def floor(_0: RelaxExpr, /) -> RelaxExpr: ...
    def floor_divide(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def floor_mod(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def full(_0: RelaxExpr | Sequence[PrimExpr], _1: RelaxExpr, _2: dtype | None, /) -> RelaxExpr: ...
    def full_like(_0: RelaxExpr, _1: RelaxExpr, _2: dtype | None, /) -> RelaxExpr: ...
    def gather_elements(_0: RelaxExpr, _1: RelaxExpr, _2: int, /) -> RelaxExpr: ...
    def gather_nd(_0: RelaxExpr, _1: RelaxExpr, _2: int, /) -> RelaxExpr: ...
    def greater(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def greater_equal(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def hamming_window(_0: PrimValue, _1: PrimValue, _2: PrimValue, _3: PrimValue, _4: dtype, /) -> RelaxExpr: ...
    def hint_on_device(*args: Any) -> Any: ...
    def index_put(_0: RelaxExpr, _1: RelaxExpr, _2: RelaxExpr, _3: bool, /) -> RelaxExpr: ...
    def index_tensor(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def invoke_closure(_0: RelaxExpr, _1: Tuple, _2: Sequence[StructInfo], /) -> RelaxExpr: ...
    def invoke_pure_closure(_0: RelaxExpr, _1: Tuple, _2: Sequence[StructInfo], /) -> RelaxExpr: ...
    def isfinite(_0: RelaxExpr, /) -> RelaxExpr: ...
    def isinf(_0: RelaxExpr, /) -> RelaxExpr: ...
    def isnan(_0: RelaxExpr, /) -> RelaxExpr: ...
    def layout_transform(_0: RelaxExpr, _1: IndexMap, _2: PrimValue | None, _3: Sequence[IntImm] | None, _4: Sequence[IntImm] | None, /) -> RelaxExpr: ...
    def left_shift(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def less(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def less_equal(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def log(_0: RelaxExpr, /) -> RelaxExpr: ...
    def log_add_exp(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def logical_and(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def logical_not(_0: RelaxExpr, /) -> RelaxExpr: ...
    def logical_or(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def logical_xor(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def make_closure(_0: RelaxExpr, _1: Tuple, /) -> RelaxExpr: ...
    def matmul(_0: RelaxExpr, _1: RelaxExpr, _2: dtype | None, /) -> RelaxExpr: ...
    def max(_0: RelaxExpr, _1: Sequence[IntImm] | None, _2: bool, /) -> RelaxExpr: ...
    def maximum(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def mean(_0: RelaxExpr, _1: Sequence[IntImm] | None, _2: bool, /) -> RelaxExpr: ...
    def meshgrid(_0: RelaxExpr, _1: str | None, /) -> RelaxExpr: ...
    def min(_0: RelaxExpr, _1: Sequence[IntImm] | None, _2: bool, /) -> RelaxExpr: ...
    def minimum(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def mod(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def multinomial_from_uniform(_0: RelaxExpr, _1: RelaxExpr, _2: RelaxExpr, _3: dtype, /) -> RelaxExpr: ...
    def multiply(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def negative(_0: RelaxExpr, /) -> RelaxExpr: ...
    def nonzero(_0: RelaxExpr, /) -> RelaxExpr: ...
    def not_equal(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def null_value() -> RelaxExpr: ...
    def one_hot(_0: RelaxExpr, _1: PrimValue, _2: PrimValue, _3: int, _4: int, /) -> RelaxExpr: ...
    def ones(_0: RelaxExpr, _1: dtype, /) -> RelaxExpr: ...
    def ones_like(_0: RelaxExpr, _1: dtype | None, /) -> RelaxExpr: ...
    def outer(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def permute_dims(_0: RelaxExpr, _1: Sequence[IntImm] | None, /) -> RelaxExpr: ...
    def power(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def print(_0: Sequence[RelaxExpr], _1: StringImm, /) -> RelaxExpr: ...
    def prod(_0: RelaxExpr, _1: Sequence[IntImm] | None, _2: bool, /) -> RelaxExpr: ...
    def quantize(_0: RelaxExpr, _1: RelaxExpr, _2: RelaxExpr, _3: int, _4: dtype, /) -> RelaxExpr: ...
    def repeat(_0: RelaxExpr, _1: int, _2: int | None, /) -> RelaxExpr: ...
    def reshape(_0: RelaxExpr, _1: RelaxExpr | Sequence[PrimExpr], /) -> RelaxExpr: ...
    def right_shift(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def round(_0: RelaxExpr, /) -> RelaxExpr: ...
    def rsqrt(_0: RelaxExpr, /) -> RelaxExpr: ...
    def scatter_elements(_0: RelaxExpr, _1: RelaxExpr, _2: RelaxExpr, _3: int, _4: str, /) -> RelaxExpr: ...
    def scatter_nd(_0: RelaxExpr, _1: RelaxExpr, _2: RelaxExpr, _3: str, /) -> RelaxExpr: ...
    def shape_of(_0: RelaxExpr, /) -> RelaxExpr: ...
    def shape_to_tensor(_0: RelaxExpr, /) -> RelaxExpr: ...
    def sigmoid(_0: RelaxExpr, /) -> RelaxExpr: ...
    def sign(_0: RelaxExpr, /) -> RelaxExpr: ...
    def sin(_0: RelaxExpr, /) -> RelaxExpr: ...
    def sinh(_0: RelaxExpr, /) -> RelaxExpr: ...
    def slice_scatter(_0: RelaxExpr, _1: RelaxExpr, _2: int, _3: PrimValue, _4: PrimValue, _5: PrimValue, /) -> RelaxExpr: ...
    def sort(_0: RelaxExpr, _1: int, _2: bool, /) -> RelaxExpr: ...
    def split(_0: RelaxExpr, _1: IntImm | Sequence[IntImm], _2: int, /) -> RelaxExpr: ...
    def sqrt(_0: RelaxExpr, /) -> RelaxExpr: ...
    def square(_0: RelaxExpr, /) -> RelaxExpr: ...
    def squeeze(_0: RelaxExpr, _1: Sequence[IntImm] | None, /) -> RelaxExpr: ...
    def stack(_0: RelaxExpr, _1: IntImm | None, /) -> RelaxExpr: ...
    def std(_0: RelaxExpr, _1: Sequence[IntImm] | None, _2: bool, /) -> RelaxExpr: ...
    def strided_slice(_0: RelaxExpr, _1: RelaxExpr, _2: RelaxExpr, _3: RelaxExpr, _4: RelaxExpr | None, _5: bool, /) -> RelaxExpr: ...
    def subtract(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def sum(_0: RelaxExpr, _1: Sequence[IntImm] | None, _2: bool, /) -> RelaxExpr: ...
    def take(_0: RelaxExpr, _1: RelaxExpr, _2: int | None, _3: str, /) -> RelaxExpr: ...
    def tan(_0: RelaxExpr, /) -> RelaxExpr: ...
    def tanh(_0: RelaxExpr, /) -> RelaxExpr: ...
    def tensor_to_shape(_0: RelaxExpr, /) -> RelaxExpr: ...
    def tile(_0: RelaxExpr, _1: Sequence[IntImm], /) -> RelaxExpr: ...
    def to_vdevice(_0: RelaxExpr, _1: VDevice, /) -> RelaxExpr: ...
    def topk(_0: RelaxExpr, _1: int, _2: int, _3: str, _4: bool, _5: dtype, /) -> RelaxExpr: ...
    def tril(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def triu(_0: RelaxExpr, _1: RelaxExpr, /) -> RelaxExpr: ...
    def trunc(_0: RelaxExpr, /) -> RelaxExpr: ...
    def unique(_0: RelaxExpr, _1: PrimValue, _2: PrimValue, _3: PrimValue, _4: PrimValue, _5: PrimValue | None, /) -> RelaxExpr: ...
    def variance(_0: RelaxExpr, _1: Sequence[IntImm] | None, _2: bool, /) -> RelaxExpr: ...
    def where(_0: RelaxExpr, _1: RelaxExpr, _2: RelaxExpr, /) -> RelaxExpr: ...
    def wrap_param(_0: RelaxExpr, _1: dtype, /) -> RelaxExpr: ...
    def zeros(_0: RelaxExpr, _1: dtype, /) -> RelaxExpr: ...
    def zeros_like(_0: RelaxExpr, _1: dtype | None, /) -> RelaxExpr: ...
# fmt: on
# tvm-ffi-stubgen(end)
