# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
"""FFI APIs"""
# tvm-ffi-stubgen(begin): import-section
# fmt: off
# isort: off
from __future__ import annotations
from tvm_ffi import init_ffi_api as _FFI_INIT_FUNC
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from collections.abc import Mapping, Sequence
    from ir import GlobalVar, IRModule, PrimExpr, RelaxExpr, StructInfo, Type
    from relax import BlockBuilder, FuncStructInfo
    from relax.expr import Binding, Call, DataflowBlock, Function, Var
    from tir import Block, IndexMap, PrimFunc, Var
    from tvm_ffi import Object
    from typing import Callable
# isort: on
# fmt: on
# tvm-ffi-stubgen(end)


# tvm-ffi-stubgen(begin): global/relax.analysis
# fmt: off
_FFI_INIT_FUNC("relax.analysis", __name__)
if TYPE_CHECKING:
    def CollectNonNegativeExpressions(_0: StructInfo, /) -> Sequence[PrimExpr]: ...
    def DefinableTIRVarsInStructInfo(_0: StructInfo, /) -> Sequence[Var]: ...
    def DefinedSymbolicVars(_0: RelaxExpr, /) -> Sequence[Var]: ...
    def DeriveCallRetStructInfo(_0: FuncStructInfo, _1: Call, _2: BlockBuilder, /) -> StructInfo: ...
    def EraseToWellDefined(_0: StructInfo, _1: Mapping[Var, PrimExpr], _2: Mapping[Var, RelaxExpr], /) -> StructInfo: ...
    def FreeSymbolicVars(_0: RelaxExpr, /) -> Sequence[Var]: ...
    def GetStaticType(_0: StructInfo, /) -> Type: ...
    def StructInfoBaseCheck(_0: StructInfo, _1: StructInfo, /) -> int: ...
    def StructInfoLCA(_0: StructInfo, _1: StructInfo, /) -> StructInfo: ...
    def TIRVarsInStructInfo(_0: StructInfo, /) -> Sequence[Var]: ...
    def all_global_vars(_0: RelaxExpr, /) -> Sequence[GlobalVar]: ...
    def all_vars(_0: RelaxExpr, /) -> Sequence[Var]: ...
    def bound_vars(_0: RelaxExpr, /) -> Sequence[Var]: ...
    def computable_at_compile_time(_0: Function, /) -> Sequence[Var]: ...
    def contains_impure_call(_0: RelaxExpr, _1: RelaxExpr | None, /) -> bool: ...
    def detect_recursion(_0: IRModule, /) -> Sequence[Sequence[GlobalVar]]: ...
    def free_vars(_0: RelaxExpr, /) -> Sequence[Var]: ...
    def get_var2val(_0: Function, /) -> Mapping[Var, RelaxExpr]: ...
    def has_reshape_pattern(_0: PrimFunc, /) -> bool: ...
    def name_to_binding(_0: Function, /) -> Mapping[str, Sequence[Binding]]: ...
    def post_order_visit(_0: RelaxExpr, _1: Callable[..., Any], /) -> None: ...
    def remove_all_unused(_0: RelaxExpr, /) -> RelaxExpr: ...
    def suggest_layout_transforms(_0: PrimFunc, _1: Sequence[IndexMap], /) -> Mapping[Block, Mapping[Object, IndexMap]]: ...
    def udchain(_0: DataflowBlock, /) -> Mapping[Var, Sequence[Var]]: ...
    def well_formed(_0: IRModule | Function, _1: bool, /) -> bool: ...
# fmt: on
# tvm-ffi-stubgen(end)
