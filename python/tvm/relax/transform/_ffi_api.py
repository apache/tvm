# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
"""FFI APIs for tvm.transform"""
# tvm-ffi-stubgen(begin): import-section
# fmt: off
# isort: off
from __future__ import annotations
from tvm_ffi import init_ffi_api as _FFI_INIT_FUNC
from typing import TYPE_CHECKING
if TYPE_CHECKING:
    from collections.abc import Mapping, Sequence
    from ir import IRModule, IntImm, PrimExpr, RelaxExpr, StructInfo, VDevice
    from relax import DataflowBlockPass, FunctionPass, MatchResult
    from relax.dpl import DFPattern
    from relax.expr import DataflowBlock, Function, Var
    from relax.transform import FusionPattern
    from tir import IndexMap, PrimFunc, Var
    from transform import Pass, PassContext, PassInfo
    from tvm_ffi import Object, Tensor, dtype
    from typing import Any, Callable
# isort: on
# fmt: on
# tvm-ffi-stubgen(end)


# tvm-ffi-stubgen(begin): global/relax.transform
# fmt: off
_FFI_INIT_FUNC("relax.transform", __name__)
if TYPE_CHECKING:
    def AdjustMatmulOrder() -> Pass: ...
    def AllocateWorkspace() -> Pass: ...
    def AlterOpImpl(_0: Mapping[str, PrimFunc], _1: Mapping[str, Sequence[IndexMap]], _2: Mapping[str, Sequence[Sequence[IntImm]] | None], _3: Mapping[str, Sequence[Sequence[IntImm]] | None], /) -> Pass: ...
    def AnnotateTIROpPattern() -> Pass: ...
    def AttachAttrLayoutFreeBuffers() -> Pass: ...
    def AttachGlobalSymbol() -> Pass: ...
    def BindParams(_0: str, _1: Mapping[Any, Object], /) -> Pass: ...
    def BindSymbolicVars(_0: Mapping[Var | str, PrimExpr], _1: str | None, /) -> Pass: ...
    def BundleModelParams(_0: str | None, /) -> Pass: ...
    def CallTIRRewrite() -> Pass: ...
    def CanonicalizeBindings() -> Pass: ...
    def CombineParallelMatmul(_0: Callable[[Var, Sequence[Var], Sequence[Var], Mapping[Var, RelaxExpr]], bool], /) -> Pass: ...
    def ComputePrimValue() -> Pass: ...
    def ConvertLayout(_0: Mapping[str, Sequence[str]], /) -> Pass: ...
    def ConvertToDataflow(_0: int, /) -> Pass: ...
    def DataflowUseInplaceCalls() -> Pass: ...
    def DeadCodeElimination(_0: Sequence[str], /) -> Pass: ...
    def DecomposeOpsForInference(_0: str | None, /) -> Pass: ...
    def DecomposeOpsForTraining(_0: str | None, /) -> Pass: ...
    def EliminateCommonSubexpr(_0: bool, /) -> Pass: ...
    def ExpandMatmulOfSum() -> Pass: ...
    def ExpandTupleArguments() -> Pass: ...
    def FewShotTuning(_0: int, _1: bool, /) -> Pass: ...
    def FoldConstant() -> Pass: ...
    def FuseOps(_0: int, /) -> Pass: ...
    def FuseOpsByPattern(_0: Sequence[FusionPattern], _1: bool, _2: bool, _3: Sequence[str], /) -> Pass: ...
    def FuseTIR() -> Pass: ...
    def FusionPattern(_0: str, _1: DFPattern, _2: Mapping[str, DFPattern], _3: Callable[..., Any] | None, _4: Callable[..., Any] | None, /) -> FusionPattern: ...
    def Gradient(_0: str, _1: Sequence[Var] | None, _2: int, /) -> Pass: ...
    def InlinePrivateFunctions() -> Pass: ...
    def KillAfterLastUse() -> Pass: ...
    def LambdaLift() -> Pass: ...
    def LazyGetInput() -> Pass: ...
    def LazySetOutput() -> Pass: ...
    def LegalizeOps(_0: Mapping[str, Callable[..., Any]] | None, _1: Sequence[str] | None, _2: bool, /) -> Pass: ...
    def LiftTransformParams(_0: IntImm | Sequence[str], /) -> Pass: ...
    def LowerAllocTensor() -> Pass: ...
    def LowerRuntimeBuiltin() -> Pass: ...
    def MakeDataflowBlockPass(_0: Callable[[ObjectRValueRef[DataflowBlock], IRModule, PassContext], DataflowBlock], _1: PassInfo, /) -> DataflowBlockPass: ...
    def MakeFunctionPass(_0: Callable[[ObjectRValueRef[Function], IRModule, PassContext], Function], _1: PassInfo, /) -> FunctionPass: ...
    def MergeCompositeFunctions() -> Pass: ...
    def MetaScheduleApplyDatabase(_0: str | None, _1: bool, /) -> Pass: ...
    def MetaScheduleTuneIRMod(_0: Mapping[str, Tensor], _1: str, _2: IntImm, _3: IntImm | None, _4: Sequence[str] | None, /) -> Pass: ...
    def MetaScheduleTuneTIR(_0: str, _1: IntImm, /) -> Pass: ...
    def Normalize() -> Pass: ...
    def NormalizeGlobalVar() -> Pass: ...
    def RealizeVDevice() -> Pass: ...
    def RemovePurityChecking() -> Pass: ...
    def RemoveUnusedOutputs() -> Pass: ...
    def RemoveUnusedParameters() -> Pass: ...
    def ReorderPermuteDimsAfterConcat() -> Pass: ...
    def ReorderTakeAfterMatmul() -> Pass: ...
    def RewriteCUDAGraph() -> Pass: ...
    def RewriteDataflowReshape() -> Pass: ...
    def RunCodegen(_0: Mapping[str, Mapping[str, Any]] | None, _1: Sequence[str], /) -> Pass: ...
    def SpecializePrimFuncBasedOnCallSite() -> Pass: ...
    def SplitCallTIRByPattern(_0: Sequence[PrimFunc], _1: Callable[[Sequence[MatchResult]], Sequence[Any]], /) -> Pass: ...
    def SplitLayoutRewritePreproc() -> Pass: ...
    def StaticPlanBlockMemory() -> Pass: ...
    def ToMixedPrecision(_0: dtype, _1: Sequence[str] | None, /) -> Pass: ...
    def ToNonDataflow() -> Pass: ...
    def TopologicalSort(_0: str, _1: str, /) -> Pass: ...
    def UpdateParamStructInfo(_0: Callable[[Var], StructInfo | None], /) -> Pass: ...
    def UpdateVDevice(_0: VDevice, _1: int, /) -> Pass: ...
    def VMShapeLower(_0: bool, /) -> Pass: ...
# fmt: on
# tvm-ffi-stubgen(end)
